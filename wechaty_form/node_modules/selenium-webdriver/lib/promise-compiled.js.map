{"version":3,"sources":["promise.js"],"names":[],"mappings":"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","file":"promise-compiled.js","sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview\n *\n * > ### IMPORTANT NOTICE\n * >\n * > The promise manager contained in this module is in the process of being\n * > phased out in favor of native JavaScript promises. This will be a long\n * > process and will not be completed until there have been two major LTS Node\n * > releases (approx. Node v10.0) that support\n * > [async functions](https://tc39.github.io/ecmascript-asyncawait/).\n * >\n * > At this time, the promise manager can be disabled by setting an environment\n * > variable, `SELENIUM_PROMISE_MANAGER=0`. In the absence of async functions,\n * > users may use generators with the\n * > {@link ./promise.consume promise.consume()} function to write \"synchronous\"\n * > style tests:\n * >\n * > ```js\n * > const {Builder, By, promise, until} = require('selenium-webdriver');\n * >\n * > let result = promise.consume(function* doGoogleSearch() {\n * >   let driver = new Builder().forBrowser('firefox').build();\n * >   yield driver.get('http://www.google.com/ncr');\n * >   yield driver.findElement(By.name('q')).sendKeys('webdriver');\n * >   yield driver.findElement(By.name('btnG')).click();\n * >   yield driver.wait(until.titleIs('webdriver - Google Search'), 1000);\n * >   yield driver.quit();\n * > });\n * >\n * > result.then(_ => console.log('SUCCESS!'),\n * >             e => console.error('FAILURE: ' + e));\n * > ```\n * >\n * > The motivation behind this change and full deprecation plan are documented\n * > in [issue 2969](https://github.com/SeleniumHQ/selenium/issues/2969).\n * >\n * >\n *\n * The promise module is centered around the {@linkplain ControlFlow}, a class\n * that coordinates the execution of asynchronous tasks. The ControlFlow allows\n * users to focus on the imperative commands for their script without worrying\n * about chaining together every single asynchronous action, which can be\n * tedious and verbose. APIs may be layered on top of the control flow to read\n * as if they were synchronous. For instance, the core\n * {@linkplain ./webdriver.WebDriver WebDriver} API is built on top of the\n * control flow, allowing users to write\n *\n *     driver.get('http://www.google.com/ncr');\n *     driver.findElement({name: 'q'}).sendKeys('webdriver');\n *     driver.findElement({name: 'btnGn'}).click();\n *\n * instead of\n *\n *     driver.get('http://www.google.com/ncr')\n *     .then(function() {\n *       return driver.findElement({name: 'q'});\n *     })\n *     .then(function(q) {\n *       return q.sendKeys('webdriver');\n *     })\n *     .then(function() {\n *       return driver.findElement({name: 'btnG'});\n *     })\n *     .then(function(btnG) {\n *       return btnG.click();\n *     });\n *\n * ## Tasks and Task Queues\n *\n * The control flow is based on the concept of tasks and task queues. Tasks are\n * functions that define the basic unit of work for the control flow to execute.\n * Each task is scheduled via {@link ControlFlow#execute()}, which will return\n * a {@link ManagedPromise} that will be resolved with the task's result.\n *\n * A task queue contains all of the tasks scheduled within a single turn of the\n * [JavaScript event loop][JSEL]. The control flow will create a new task queue\n * the first time a task is scheduled within an event loop.\n *\n *     var flow = promise.controlFlow();\n *     flow.execute(foo);       // Creates a new task queue and inserts foo.\n *     flow.execute(bar);       // Inserts bar into the same queue as foo.\n *     setTimeout(function() {\n *       flow.execute(baz);     // Creates a new task queue and inserts baz.\n *     }, 0);\n *\n * Whenever the control flow creates a new task queue, it will automatically\n * begin executing tasks in the next available turn of the event loop. This\n * execution is [scheduled as a microtask][MicrotasksArticle] like e.g. a\n * (native) `Promise.then()` callback.\n *\n *     setTimeout(() => console.log('a'));\n *     Promise.resolve().then(() => console.log('b'));  // A native promise.\n *     flow.execute(() => console.log('c'));\n *     Promise.resolve().then(() => console.log('d'));\n *     setTimeout(() => console.log('fin'));\n *     // b\n *     // c\n *     // d\n *     // a\n *     // fin\n *\n * In the example above, b/c/d is logged before a/fin because native promises\n * and this module use \"microtask\" timers, which have a higher priority than\n * \"macrotasks\" like `setTimeout`.\n *\n * ## Task Execution\n *\n * Upon creating a task queue, and whenever an existing queue completes a task,\n * the control flow will schedule a microtask timer to process any scheduled\n * tasks. This ensures no task is ever started within the same turn of the\n * JavaScript event loop in which it was scheduled, nor is a task ever started\n * within the same turn that another finishes.\n *\n * When the execution timer fires, a single task will be dequeued and executed.\n * There are several important events that may occur while executing a task\n * function:\n *\n * 1. A new task queue is created by a call to {@link ControlFlow#execute()}.\n *    Any tasks scheduled within this task queue are considered subtasks of the\n *    current task.\n * 2. The task function throws an error. Any scheduled tasks are immediately\n *    discarded and the task's promised result (previously returned by\n *    {@link ControlFlow#execute()}) is immediately rejected with the thrown\n *    error.\n * 3. The task function returns successfully.\n *\n * If a task function created a new task queue, the control flow will wait for\n * that queue to complete before processing the task result. If the queue\n * completes without error, the flow will settle the task's promise with the\n * value originally returned by the task function. On the other hand, if the task\n * queue terminates with an error, the task's promise will be rejected with that\n * error.\n *\n *     flow.execute(function() {\n *       flow.execute(() => console.log('a'));\n *       flow.execute(() => console.log('b'));\n *     });\n *     flow.execute(() => console.log('c'));\n *     // a\n *     // b\n *     // c\n *\n * ## ManagedPromise Integration\n *\n * In addition to the {@link ControlFlow} class, the promise module also exports\n * a [Promises/A+] {@linkplain ManagedPromise implementation} that is deeply\n * integrated with the ControlFlow. First and foremost, each promise\n * {@linkplain ManagedPromise#then() callback} is scheduled with the\n * control flow as a task. As a result, each callback is invoked in its own turn\n * of the JavaScript event loop with its own task queue. If any tasks are\n * scheduled within a callback, the callback's promised result will not be\n * settled until the task queue has completed.\n *\n *     promise.fulfilled().then(function() {\n *       flow.execute(function() {\n *         console.log('b');\n *       });\n *     }).then(() => console.log('a'));\n *     // b\n *     // a\n *\n * ### Scheduling ManagedPromise Callbacks <a id=\"scheduling_callbacks\"></a>\n *\n * How callbacks are scheduled in the control flow depends on when they are\n * attached to the promise. Callbacks attached to a _previously_ resolved\n * promise are immediately enqueued as subtasks of the currently running task.\n *\n *     var p = promise.fulfilled();\n *     flow.execute(function() {\n *       flow.execute(() => console.log('A'));\n *       p.then(      () => console.log('B'));\n *       flow.execute(() => console.log('C'));\n *       p.then(      () => console.log('D'));\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // B\n *     // C\n *     // D\n *     // fin\n *\n * When a promise is resolved while a task function is on the call stack, any\n * callbacks also registered in that stack frame are scheduled as if the promise\n * were already resolved:\n *\n *     var d = promise.defer();\n *     flow.execute(function() {\n *       flow.execute(  () => console.log('A'));\n *       d.promise.then(() => console.log('B'));\n *       flow.execute(  () => console.log('C'));\n *       d.promise.then(() => console.log('D'));\n *\n *       d.fulfill();\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // B\n *     // C\n *     // D\n *     // fin\n *\n * Callbacks attached to an _unresolved_ promise within a task function are\n * only weakly scheduled as subtasks and will be dropped if they reach the\n * front of the queue before the promise is resolved. In the example below, the\n * callbacks for `B` & `D` are dropped as sub-tasks since they are attached to\n * an unresolved promise when they reach the front of the task queue.\n *\n *     var d = promise.defer();\n *     flow.execute(function() {\n *       flow.execute(  () => console.log('A'));\n *       d.promise.then(() => console.log('B'));\n *       flow.execute(  () => console.log('C'));\n *       d.promise.then(() => console.log('D'));\n *\n *       setTimeout(d.fulfill, 20);\n *     }).then(function() {\n *       console.log('fin')\n *     });\n *     // A\n *     // C\n *     // fin\n *     // B\n *     // D\n *\n * If a promise is resolved while a task function is on the call stack, any\n * previously registered and unqueued callbacks (i.e. either attached while no\n * task was on the call stack, or previously dropped as described above) act as\n * _interrupts_ and are inserted at the front of the task queue. If multiple\n * promises are fulfilled, their interrupts are enqueued in the order the\n * promises are resolved.\n *\n *     var d1 = promise.defer();\n *     d1.promise.then(() => console.log('A'));\n *\n *     var d2 = promise.defer();\n *     d2.promise.then(() => console.log('B'));\n *\n *     flow.execute(function() {\n *       d1.promise.then(() => console.log('C'));\n *       flow.execute(() => console.log('D'));\n *     });\n *     flow.execute(function() {\n *       flow.execute(() => console.log('E'));\n *       flow.execute(() => console.log('F'));\n *       d1.fulfill();\n *       d2.fulfill();\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // D\n *     // A\n *     // C\n *     // B\n *     // E\n *     // F\n *     // fin\n *\n * Within a task function (or callback), each step of a promise chain acts as\n * an interrupt on the task queue:\n *\n *     var d = promise.defer();\n *     flow.execute(function() {\n *       d.promise.\n *           then(() => console.log('A')).\n *           then(() => console.log('B')).\n *           then(() => console.log('C')).\n *           then(() => console.log('D'));\n *\n *       flow.execute(() => console.log('E'));\n *       d.fulfill();\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // B\n *     // C\n *     // D\n *     // E\n *     // fin\n *\n * If there are multiple promise chains derived from a single promise, they are\n * processed in the order created:\n *\n *     var d = promise.defer();\n *     flow.execute(function() {\n *       var chain = d.promise.then(() => console.log('A'));\n *\n *       chain.then(() => console.log('B')).\n *           then(() => console.log('C'));\n *\n *       chain.then(() => console.log('D')).\n *           then(() => console.log('E'));\n *\n *       flow.execute(() => console.log('F'));\n *\n *       d.fulfill();\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // B\n *     // C\n *     // D\n *     // E\n *     // F\n *     // fin\n *\n * Even though a subtask's promised result will never resolve while the task\n * function is on the stack, it will be treated as a promise resolved within the\n * task. In all other scenarios, a task's promise behaves just like a normal\n * promise. In the sample below, `C/D` is logged before `B` because the\n * resolution of `subtask1` interrupts the flow of the enclosing task. Within\n * the final subtask, `E/F` is logged in order because `subtask1` is a resolved\n * promise when that task runs.\n *\n *     flow.execute(function() {\n *       var subtask1 = flow.execute(() => console.log('A'));\n *       var subtask2 = flow.execute(() => console.log('B'));\n *\n *       subtask1.then(() => console.log('C'));\n *       subtask1.then(() => console.log('D'));\n *\n *       flow.execute(function() {\n *         flow.execute(() => console.log('E'));\n *         subtask1.then(() => console.log('F'));\n *       });\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // C\n *     // D\n *     // B\n *     // E\n *     // F\n *     // fin\n *\n * Finally, consider the following:\n *\n *     var d = promise.defer();\n *     d.promise.then(() => console.log('A'));\n *     d.promise.then(() => console.log('B'));\n *\n *     flow.execute(function() {\n *       flow.execute(  () => console.log('C'));\n *       d.promise.then(() => console.log('D'));\n *\n *       flow.execute(  () => console.log('E'));\n *       d.promise.then(() => console.log('F'));\n *\n *       d.fulfill();\n *\n *       flow.execute(  () => console.log('G'));\n *       d.promise.then(() => console.log('H'));\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // B\n *     // C\n *     // D\n *     // E\n *     // F\n *     // G\n *     // H\n *     // fin\n *\n * In this example, callbacks are registered on `d.promise` both before and\n * during the invocation of the task function. When `d.fulfill()` is called,\n * the callbacks registered before the task (`A` & `B`) are registered as\n * interrupts. The remaining callbacks were all attached within the task and\n * are scheduled in the flow as standard tasks.\n *\n * ## Generator Support\n *\n * [Generators][GF] may be scheduled as tasks within a control flow or attached\n * as callbacks to a promise. Each time the generator yields a promise, the\n * control flow will wait for that promise to settle before executing the next\n * iteration of the generator. The yielded promise's fulfilled value will be\n * passed back into the generator:\n *\n *     flow.execute(function* () {\n *       var d = promise.defer();\n *\n *       setTimeout(() => console.log('...waiting...'), 25);\n *       setTimeout(() => d.fulfill(123), 50);\n *\n *       console.log('start: ' + Date.now());\n *\n *       var value = yield d.promise;\n *       console.log('mid: %d; value = %d', Date.now(), value);\n *\n *       yield promise.delayed(10);\n *       console.log('end: ' + Date.now());\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // start: 0\n *     // ...waiting...\n *     // mid: 50; value = 123\n *     // end: 60\n *     // fin\n *\n * Yielding the result of a promise chain will wait for the entire chain to\n * complete:\n *\n *     promise.fulfilled().then(function* () {\n *       console.log('start: ' + Date.now());\n *\n *       var value = yield flow.\n *           execute(() => console.log('A')).\n *           then(   () => console.log('B')).\n *           then(   () => 123);\n *\n *       console.log('mid: %s; value = %d', Date.now(), value);\n *\n *       yield flow.execute(() => console.log('C'));\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // start: 0\n *     // A\n *     // B\n *     // mid: 2; value = 123\n *     // C\n *     // fin\n *\n * Yielding a _rejected_ promise will cause the rejected value to be thrown\n * within the generator function:\n *\n *     flow.execute(function* () {\n *       console.log('start: ' + Date.now());\n *       try {\n *         yield promise.delayed(10).then(function() {\n *           throw Error('boom');\n *         });\n *       } catch (ex) {\n *         console.log('caught time: ' + Date.now());\n *         console.log(ex.message);\n *       }\n *     });\n *     // start: 0\n *     // caught time: 10\n *     // boom\n *\n * # Error Handling\n *\n * ES6 promises do not require users to handle a promise rejections. This can\n * result in subtle bugs as the rejections are silently \"swallowed\" by the\n * Promise class.\n *\n *     Promise.reject(Error('boom'));\n *     // ... *crickets* ...\n *\n * Selenium's promise module, on the other hand, requires that every rejection\n * be explicitly handled. When a {@linkplain ManagedPromise ManagedPromise} is\n * rejected and no callbacks are defined on that promise, it is considered an\n * _unhandled rejection_ and reported to the active task queue. If the rejection\n * remains unhandled after a single turn of the [event loop][JSEL] (scheduled\n * with a microtask), it will propagate up the stack.\n *\n * ## Error Propagation\n *\n * If an unhandled rejection occurs within a task function, that task's promised\n * result is rejected and all remaining subtasks are discarded:\n *\n *     flow.execute(function() {\n *       // No callbacks registered on promise -> unhandled rejection\n *       promise.rejected(Error('boom'));\n *       flow.execute(function() { console.log('this will never run'); });\n *     }).catch(function(e) {\n *       console.log(e.message);\n *     });\n *     // boom\n *\n * The promised results for discarded tasks are silently rejected with a\n * cancellation error and existing callback chains will never fire.\n *\n *     flow.execute(function() {\n *       promise.rejected(Error('boom'));\n *       flow.execute(function() { console.log('a'); }).\n *           then(function() { console.log('b'); });\n *     }).catch(function(e) {\n *       console.log(e.message);\n *     });\n *     // boom\n *\n * An unhandled rejection takes precedence over a task function's returned\n * result, even if that value is another promise:\n *\n *     flow.execute(function() {\n *       promise.rejected(Error('boom'));\n *       return flow.execute(someOtherTask);\n *     }).catch(function(e) {\n *       console.log(e.message);\n *     });\n *     // boom\n *\n * If there are multiple unhandled rejections within a task, they are packaged\n * in a {@link MultipleUnhandledRejectionError}, which has an `errors` property\n * that is a `Set` of the recorded unhandled rejections:\n *\n *     flow.execute(function() {\n *       promise.rejected(Error('boom1'));\n *       promise.rejected(Error('boom2'));\n *     }).catch(function(ex) {\n *       console.log(ex instanceof MultipleUnhandledRejectionError);\n *       for (var e of ex.errors) {\n *         console.log(e.message);\n *       }\n *     });\n *     // boom1\n *     // boom2\n *\n * When a subtask is discarded due to an unreported rejection in its parent\n * frame, the existing callbacks on that task will never settle and the\n * callbacks will not be invoked. If a new callback is attached to the subtask\n * _after_ it has been discarded, it is handled the same as adding a callback\n * to a cancelled promise: the error-callback path is invoked. This behavior is\n * intended to handle cases where the user saves a reference to a task promise,\n * as illustrated below.\n *\n *     var subTask;\n *     flow.execute(function() {\n *       promise.rejected(Error('boom'));\n *       subTask = flow.execute(function() {});\n *     }).catch(function(e) {\n *       console.log(e.message);\n *     }).then(function() {\n *       return subTask.then(\n *           () => console.log('subtask success!'),\n *           (e) => console.log('subtask failed:\\n' + e));\n *     });\n *     // boom\n *     // subtask failed:\n *     // DiscardedTaskError: Task was discarded due to a previous failure: boom\n *\n * When a subtask fails, its promised result is treated the same as any other\n * promise: it must be handled within one turn of the rejection or the unhandled\n * rejection is propagated to the parent task. This means users can catch errors\n * from complex flows from the top level task:\n *\n *     flow.execute(function() {\n *       flow.execute(function() {\n *         flow.execute(function() {\n *           throw Error('fail!');\n *         });\n *       });\n *     }).catch(function(e) {\n *       console.log(e.message);\n *     });\n *     // fail!\n *\n * ## Unhandled Rejection Events\n *\n * When an unhandled rejection propagates to the root of the control flow, the\n * flow will emit an __uncaughtException__ event. If no listeners are registered\n * on the flow, the error will be rethrown to the global error handler: an\n * __uncaughtException__ event from the\n * [`process`](https://nodejs.org/api/process.html) object in node, or\n * `window.onerror` when running in a browser.\n *\n * Bottom line: you __*must*__ handle rejected promises.\n *\n * # Promises/A+ Compatibility\n *\n * This `promise` module is compliant with the [Promises/A+] specification\n * except for sections `2.2.6.1` and `2.2.6.2`:\n *\n * >\n * > - `then` may be called multiple times on the same promise.\n * >    - If/when `promise` is fulfilled, all respective `onFulfilled` callbacks\n * >      must execute in the order of their originating calls to `then`.\n * >    - If/when `promise` is rejected, all respective `onRejected` callbacks\n * >      must execute in the order of their originating calls to `then`.\n * >\n *\n * Specifically, the conformance tests contain the following scenario (for\n * brevity, only the fulfillment version is shown):\n *\n *     var p1 = Promise.resolve();\n *     p1.then(function() {\n *       console.log('A');\n *       p1.then(() => console.log('B'));\n *     });\n *     p1.then(() => console.log('C'));\n *     // A\n *     // C\n *     // B\n *\n * Since the [ControlFlow](#scheduling_callbacks) executes promise callbacks as\n * tasks, with this module, the result would be:\n *\n *     var p2 = promise.fulfilled();\n *     p2.then(function() {\n *       console.log('A');\n *       p2.then(() => console.log('B');\n *     });\n *     p2.then(() => console.log('C'));\n *     // A\n *     // B\n *     // C\n *\n * [JSEL]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop\n * [GF]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*\n * [Promises/A+]: https://promisesaplus.com/\n * [MicrotasksArticle]: https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n */\n\n'use strict';\n\nconst error = require('./error');\nconst events = require('./events');\nconst logging = require('./logging');\n\n\n/**\n * Alias to help with readability and differentiate types.\n * @const\n */\nconst NativePromise = Promise;\n\n\n/**\n * Whether to append traces of `then` to rejection errors.\n * @type {boolean}\n */\nvar LONG_STACK_TRACES = false;  // TODO: this should not be CONSTANT_CASE\n\n\n/** @const */\nconst LOG = logging.getLogger('promise');\n\n\nconst UNIQUE_IDS = new WeakMap;\nlet nextId = 1;\n\n\nfunction getUid(obj) {\n  let id = UNIQUE_IDS.get(obj);\n  if (!id) {\n    id = nextId;\n    nextId += 1;\n    UNIQUE_IDS.set(obj, id);\n  }\n  return id;\n}\n\n\n/**\n * Runs the given function after a microtask yield.\n * @param {function()} fn The function to run.\n */\nfunction asyncRun(fn) {\n  NativePromise.resolve().then(function() {\n    try {\n      fn();\n    } catch (ignored) {\n      // Do nothing.\n    }\n  });\n}\n\n/**\n * @param {number} level What level of verbosity to log with.\n * @param {(string|function(this: T): string)} loggable The message to log.\n * @param {T=} opt_self The object in whose context to run the loggable\n *     function.\n * @template T\n */\nfunction vlog(level, loggable, opt_self) {\n  var logLevel = logging.Level.FINE;\n  if (level > 1) {\n    logLevel = logging.Level.FINEST;\n  } else if (level > 0) {\n    logLevel = logging.Level.FINER;\n  }\n\n  if (typeof loggable === 'function') {\n    loggable = loggable.bind(opt_self);\n  }\n\n  LOG.log(logLevel, loggable);\n}\n\n\n/**\n * Generates an error to capture the current stack trace.\n * @param {string} name Error name for this stack trace.\n * @param {string} msg Message to record.\n * @param {Function=} opt_topFn The function that should appear at the top of\n *     the stack; only applicable in V8.\n * @return {!Error} The generated error.\n */\nfunction captureStackTrace(name, msg, opt_topFn) {\n  var e = Error(msg);\n  e.name = name;\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(e, opt_topFn);\n  } else {\n    var stack = Error().stack;\n    if (stack) {\n      e.stack = e.toString();\n      e.stack += '\\n' + stack;\n    }\n  }\n  return e;\n}\n\n\n/**\n * Error used when the computation of a promise is cancelled.\n */\nclass CancellationError extends Error {\n  /**\n   * @param {string=} opt_msg The cancellation message.\n   */\n  constructor(opt_msg) {\n    super(opt_msg);\n\n    /** @override */\n    this.name = this.constructor.name;\n\n    /** @private {boolean} */\n    this.silent_ = false;\n  }\n\n  /**\n   * Wraps the given error in a CancellationError.\n   *\n   * @param {*} error The error to wrap.\n   * @param {string=} opt_msg The prefix message to use.\n   * @return {!CancellationError} A cancellation error.\n   */\n  static wrap(error, opt_msg) {\n    var message;\n    if (error instanceof CancellationError) {\n      return new CancellationError(\n          opt_msg ? (opt_msg + ': ' + error.message) : error.message);\n    } else if (opt_msg) {\n      message = opt_msg;\n      if (error) {\n        message += ': ' + error;\n      }\n      return new CancellationError(message);\n    }\n    if (error) {\n      message = error + '';\n    }\n    return new CancellationError(message);\n  }\n}\n\n\n/**\n * Error used to cancel tasks when a control flow is reset.\n * @final\n */\nclass FlowResetError extends CancellationError {\n  constructor() {\n    super('ControlFlow was reset');\n    this.silent_ = true;\n  }\n}\n\n\n/**\n * Error used to cancel tasks that have been discarded due to an uncaught error\n * reported earlier in the control flow.\n * @final\n */\nclass DiscardedTaskError extends CancellationError {\n  /** @param {*} error The original error. */\n  constructor(error) {\n    if (error instanceof DiscardedTaskError) {\n      return /** @type {!DiscardedTaskError} */(error);\n    }\n\n    var msg = '';\n    if (error) {\n      msg = ': ' + (\n          typeof error.message === 'string' ? error.message : error);\n    }\n\n    super('Task was discarded due to a previous failure' + msg);\n    this.silent_ = true;\n  }\n}\n\n\n/**\n * Error used when there are multiple unhandled promise rejections detected\n * within a task or callback.\n *\n * @final\n */\nclass MultipleUnhandledRejectionError extends Error {\n  /**\n   * @param {!(Set<*>)} errors The errors to report.\n   */\n  constructor(errors) {\n    super('Multiple unhandled promise rejections reported');\n\n    /** @override */\n    this.name = this.constructor.name;\n\n    /** @type {!Set<*>} */\n    this.errors = errors;\n  }\n}\n\n\n/**\n * Property used to flag constructor's as implementing the Thenable interface\n * for runtime type checking.\n * @const\n */\nconst IMPLEMENTED_BY_SYMBOL = Symbol('promise.Thenable');\nconst CANCELLABLE_SYMBOL = Symbol('promise.CancellableThenable');\n\n\n/**\n * @param {function(new: ?)} ctor\n * @param {!Object} symbol\n */\nfunction addMarkerSymbol(ctor, symbol) {\n  try {\n    ctor.prototype[symbol] = true;\n  } catch (ignored) {\n    // Property access denied?\n  }\n}\n\n\n/**\n * @param {*} object\n * @param {!Object} symbol\n * @return {boolean}\n */\nfunction hasMarkerSymbol(object, symbol) {\n  if (!object) {\n    return false;\n  }\n  try {\n    return !!object[symbol];\n  } catch (e) {\n    return false;  // Property access seems to be forbidden.\n  }\n}\n\n\n/**\n * Thenable is a promise-like object with a {@code then} method which may be\n * used to schedule callbacks on a promised value.\n *\n * @record\n * @extends {IThenable<T>}\n * @template T\n */\nclass Thenable {\n  /**\n   * Adds a property to a class prototype to allow runtime checks of whether\n   * instances of that class implement the Thenable interface.\n   * @param {function(new: Thenable, ...?)} ctor The\n   *     constructor whose prototype to modify.\n   */\n  static addImplementation(ctor) {\n    addMarkerSymbol(ctor, IMPLEMENTED_BY_SYMBOL);\n  }\n\n  /**\n   * Checks if an object has been tagged for implementing the Thenable\n   * interface as defined by {@link Thenable.addImplementation}.\n   * @param {*} object The object to test.\n   * @return {boolean} Whether the object is an implementation of the Thenable\n   *     interface.\n   */\n  static isImplementation(object) {\n    return hasMarkerSymbol(object, IMPLEMENTED_BY_SYMBOL);\n  }\n\n  /**\n   * Registers listeners for when this instance is resolved.\n   *\n   * @param {?(function(T): (R|IThenable<R>))=} opt_callback The\n   *     function to call if this promise is successfully resolved. The function\n   *     should expect a single argument: the promise's resolved value.\n   * @param {?(function(*): (R|IThenable<R>))=} opt_errback\n   *     The function to call if this promise is rejected. The function should\n   *     expect a single argument: the rejection reason.\n   * @return {!Thenable<R>} A new promise which will be resolved with the result\n   *     of the invoked callback.\n   * @template R\n   */\n  then(opt_callback, opt_errback) {}\n\n  /**\n   * Registers a listener for when this promise is rejected. This is synonymous\n   * with the {@code catch} clause in a synchronous API:\n   *\n   *     // Synchronous API:\n   *     try {\n   *       doSynchronousWork();\n   *     } catch (ex) {\n   *       console.error(ex);\n   *     }\n   *\n   *     // Asynchronous promise API:\n   *     doAsynchronousWork().catch(function(ex) {\n   *       console.error(ex);\n   *     });\n   *\n   * @param {function(*): (R|IThenable<R>)} errback The\n   *     function to call if this promise is rejected. The function should\n   *     expect a single argument: the rejection reason.\n   * @return {!Thenable<R>} A new promise which will be resolved with the result\n   *     of the invoked callback.\n   * @template R\n   */\n  catch(errback) {}\n}\n\n\n/**\n * Marker interface for objects that allow consumers to request the cancellation\n * of a promise-based operation. A cancelled promise will be rejected with a\n * {@link CancellationError}.\n *\n * This interface is considered package-private and should not be used outside\n * of selenium-webdriver.\n *\n * @interface\n * @extends {Thenable<T>}\n * @template T\n * @package\n */\nclass CancellableThenable {\n  /**\n   * @param {function(new: CancellableThenable, ...?)} ctor\n   */\n  static addImplementation(ctor) {\n    Thenable.addImplementation(ctor);\n    addMarkerSymbol(ctor, CANCELLABLE_SYMBOL);\n  }\n\n  /**\n   * @param {*} object\n   * @return {boolean}\n   */\n  static isImplementation(object) {\n    return hasMarkerSymbol(object, CANCELLABLE_SYMBOL);\n  }\n\n  /**\n   * Requests the cancellation of the computation of this promise's value,\n   * rejecting the promise in the process. This method is a no-op if the promise\n   * has already been resolved.\n   *\n   * @param {(string|Error)=} opt_reason The reason this promise is being\n   *     cancelled. This value will be wrapped in a {@link CancellationError}.\n   */\n  cancel(opt_reason) {}\n}\n\n\n/**\n * @enum {string}\n */\nconst PromiseState = {\n  PENDING: 'pending',\n  BLOCKED: 'blocked',\n  REJECTED: 'rejected',\n  FULFILLED: 'fulfilled'\n};\n\n\n/**\n * Internal map used to store cancellation handlers for {@link ManagedPromise}\n * objects. This is an internal implementation detail used by the\n * {@link TaskQueue} class to monitor for when a promise is cancelled without\n * generating an extra promise via then().\n *\n * @const {!WeakMap<!ManagedPromise, function(!CancellationError)>}\n */\nconst ON_CANCEL_HANDLER = new WeakMap;\n\nconst SKIP_LOG = Symbol('skip-log');\nconst FLOW_LOG = logging.getLogger('promise.ControlFlow');\n\n\n/**\n * Represents the eventual value of a completed operation. Each promise may be\n * in one of three states: pending, fulfilled, or rejected. Each promise starts\n * in the pending state and may make a single transition to either a\n * fulfilled or rejected state, at which point the promise is considered\n * resolved.\n *\n * @implements {CancellableThenable<T>}\n * @template T\n * @see http://promises-aplus.github.io/promises-spec/\n */\nclass ManagedPromise {\n  /**\n   * @param {function(\n   *           function((T|IThenable<T>|Thenable)=),\n   *           function(*=))} resolver\n   *     Function that is invoked immediately to begin computation of this\n   *     promise's value. The function should accept a pair of callback\n   *     functions, one for fulfilling the promise and another for rejecting it.\n   * @param {ControlFlow=} opt_flow The control flow\n   *     this instance was created under. Defaults to the currently active flow.\n   * @param {?=} opt_skipLog An internal parameter used to skip logging the\n   *     creation of this promise. This parameter has no effect unless it is\n   *     strictly equal to an internal symbol. In other words, this parameter\n   *     is always ignored for external code.\n   */\n  constructor(resolver, opt_flow, opt_skipLog) {\n    if (!usePromiseManager()) {\n      throw TypeError(\n        'Unable to create a managed promise instance: the promise manager has'\n            + ' been disabled by the SELENIUM_PROMISE_MANAGER environment'\n            + ' variable: ' + process.env['SELENIUM_PROMISE_MANAGER']);\n    } else if (opt_skipLog !== SKIP_LOG) {\n      FLOW_LOG.warning(() => {\n        let e =\n            captureStackTrace(\n                'ManagedPromiseError',\n                'Creating a new managed Promise. This call will fail when the'\n                    + ' promise manager is disabled',\n            ManagedPromise)\n        return e.stack;\n      });\n    }\n\n    getUid(this);\n\n    /** @private {!ControlFlow} */\n    this.flow_ = opt_flow || controlFlow();\n\n    /** @private {Error} */\n    this.stack_ = null;\n    if (LONG_STACK_TRACES) {\n      this.stack_ = captureStackTrace('ManagedPromise', 'new', this.constructor);\n    }\n\n    /** @private {Thenable<?>} */\n    this.parent_ = null;\n\n    /** @private {Array<!Task>} */\n    this.callbacks_ = null;\n\n    /** @private {PromiseState} */\n    this.state_ = PromiseState.PENDING;\n\n    /** @private {boolean} */\n    this.handled_ = false;\n\n    /** @private {*} */\n    this.value_ = undefined;\n\n    /** @private {TaskQueue} */\n    this.queue_ = null;\n\n    try {\n      var self = this;\n      resolver(function(value) {\n        self.resolve_(PromiseState.FULFILLED, value);\n      }, function(reason) {\n        self.resolve_(PromiseState.REJECTED, reason);\n      });\n    } catch (ex) {\n      this.resolve_(PromiseState.REJECTED, ex);\n    }\n  }\n\n  /**\n   * Creates a promise that is immediately resolved with the given value.\n   *\n   * @param {T=} opt_value The value to resolve.\n   * @return {!ManagedPromise<T>} A promise resolved with the given value.\n   * @template T\n   */\n  static resolve(opt_value) {\n    if (opt_value instanceof ManagedPromise) {\n      return opt_value;\n    }\n    return new ManagedPromise(resolve => resolve(opt_value));\n  }\n\n  /**\n   * Creates a promise that is immediately rejected with the given reason.\n   *\n   * @param {*=} opt_reason The rejection reason.\n   * @return {!ManagedPromise<?>} A new rejected promise.\n   */\n  static reject(opt_reason) {\n    return new ManagedPromise((_, reject) => reject(opt_reason));\n  }\n\n  /** @override */\n  toString() {\n    return 'ManagedPromise::' + getUid(this) +\n      ' {[[PromiseStatus]]: \"' + this.state_ + '\"}';\n  }\n\n  /**\n   * Resolves this promise. If the new value is itself a promise, this function\n   * will wait for it to be resolved before notifying the registered listeners.\n   * @param {PromiseState} newState The promise's new state.\n   * @param {*} newValue The promise's new value.\n   * @throws {TypeError} If {@code newValue === this}.\n   * @private\n   */\n  resolve_(newState, newValue) {\n    if (PromiseState.PENDING !== this.state_) {\n      return;\n    }\n\n    if (newValue === this) {\n      // See promise a+, 2.3.1\n      // http://promises-aplus.github.io/promises-spec/#point-48\n      newValue = new TypeError('A promise may not resolve to itself');\n      newState = PromiseState.REJECTED;\n    }\n\n    this.parent_ = null;\n    this.state_ = PromiseState.BLOCKED;\n\n    if (newState !== PromiseState.REJECTED) {\n      if (Thenable.isImplementation(newValue)) {\n        // 2.3.2\n        newValue = /** @type {!Thenable} */(newValue);\n        this.parent_ = newValue;\n        newValue.then(\n            this.unblockAndResolve_.bind(this, PromiseState.FULFILLED),\n            this.unblockAndResolve_.bind(this, PromiseState.REJECTED));\n        return;\n\n      } else if (newValue\n          && (typeof newValue === 'object' || typeof newValue === 'function')) {\n        // 2.3.3\n\n        try {\n          // 2.3.3.1\n          var then = newValue['then'];\n        } catch (e) {\n          // 2.3.3.2\n          this.state_ = PromiseState.REJECTED;\n          this.value_ = e;\n          this.scheduleNotifications_();\n          return;\n        }\n\n        if (typeof then === 'function') {\n          // 2.3.3.3\n          this.invokeThen_(/** @type {!Object} */(newValue), then);\n          return;\n        }\n      }\n    }\n\n    if (newState === PromiseState.REJECTED &&\n        isError(newValue) && newValue.stack && this.stack_) {\n      newValue.stack += '\\nFrom: ' + (this.stack_.stack || this.stack_);\n    }\n\n    // 2.3.3.4 and 2.3.4\n    this.state_ = newState;\n    this.value_ = newValue;\n    this.scheduleNotifications_();\n  }\n\n  /**\n   * Invokes a thenable's \"then\" method according to 2.3.3.3 of the promise\n   * A+ spec.\n   * @param {!Object} x The thenable object.\n   * @param {!Function} then The \"then\" function to invoke.\n   * @private\n   */\n  invokeThen_(x, then) {\n    var called = false;\n    var self = this;\n\n    var resolvePromise = function(value) {\n      if (!called) {  // 2.3.3.3.3\n        called = true;\n        // 2.3.3.3.1\n        self.unblockAndResolve_(PromiseState.FULFILLED, value);\n      }\n    };\n\n    var rejectPromise = function(reason) {\n      if (!called) {  // 2.3.3.3.3\n        called = true;\n        // 2.3.3.3.2\n        self.unblockAndResolve_(PromiseState.REJECTED, reason);\n      }\n    };\n\n    try {\n      // 2.3.3.3\n      then.call(x, resolvePromise, rejectPromise);\n    } catch (e) {\n      // 2.3.3.3.4.2\n      rejectPromise(e);\n    }\n  }\n\n  /**\n   * @param {PromiseState} newState The promise's new state.\n   * @param {*} newValue The promise's new value.\n   * @private\n   */\n  unblockAndResolve_(newState, newValue) {\n    if (this.state_ === PromiseState.BLOCKED) {\n      this.state_ = PromiseState.PENDING;\n      this.resolve_(newState, newValue);\n    }\n  }\n\n  /**\n   * @private\n   */\n  scheduleNotifications_() {\n    vlog(2, () => this + ' scheduling notifications', this);\n\n    ON_CANCEL_HANDLER.delete(this);\n    if (this.value_ instanceof CancellationError\n        && this.value_.silent_) {\n      this.callbacks_ = null;\n    }\n\n    if (!this.queue_) {\n      this.queue_ = this.flow_.getActiveQueue_();\n    }\n\n    if (!this.handled_ &&\n        this.state_ === PromiseState.REJECTED &&\n        !(this.value_ instanceof CancellationError)) {\n      this.queue_.addUnhandledRejection(this);\n    }\n    this.queue_.scheduleCallbacks(this);\n  }\n\n  /** @override */\n  cancel(opt_reason) {\n    if (!canCancel(this)) {\n      return;\n    }\n\n    if (this.parent_ && canCancel(this.parent_)) {\n      /** @type {!CancellableThenable} */(this.parent_).cancel(opt_reason);\n    } else {\n      var reason = CancellationError.wrap(opt_reason);\n      let onCancel = ON_CANCEL_HANDLER.get(this);\n      if (onCancel) {\n        onCancel(reason);\n        ON_CANCEL_HANDLER.delete(this);\n      }\n\n      if (this.state_ === PromiseState.BLOCKED) {\n        this.unblockAndResolve_(PromiseState.REJECTED, reason);\n      } else {\n        this.resolve_(PromiseState.REJECTED, reason);\n      }\n    }\n\n    function canCancel(promise) {\n      if (!(promise instanceof ManagedPromise)) {\n        return CancellableThenable.isImplementation(promise);\n      }\n      return promise.state_ === PromiseState.PENDING\n          || promise.state_ === PromiseState.BLOCKED;\n    }\n  }\n\n  /** @override */\n  then(opt_callback, opt_errback) {\n    return this.addCallback_(\n        opt_callback, opt_errback, 'then', ManagedPromise.prototype.then);\n  }\n\n  /** @override */\n  catch(errback) {\n    return this.addCallback_(\n        null, errback, 'catch', ManagedPromise.prototype.catch);\n  }\n\n  /**\n   * @param {function(): (R|IThenable<R>)} callback\n   * @return {!ManagedPromise<R>}\n   * @template R\n   * @see ./promise.finally()\n   */\n  finally(callback) {\n    let result = thenFinally(this, callback);\n    return /** @type {!ManagedPromise} */(result);\n  }\n\n  /**\n   * Registers a new callback with this promise\n   * @param {(function(T): (R|IThenable<R>)|null|undefined)} callback The\n   *    fulfillment callback.\n   * @param {(function(*): (R|IThenable<R>)|null|undefined)} errback The\n   *    rejection callback.\n   * @param {string} name The callback name.\n   * @param {!Function} fn The function to use as the top of the stack when\n   *     recording the callback's creation point.\n   * @return {!ManagedPromise<R>} A new promise which will be resolved with the\n   *     result of the invoked callback.\n   * @template R\n   * @private\n   */\n  addCallback_(callback, errback, name, fn) {\n    if (typeof callback !== 'function' && typeof errback !== 'function') {\n      return this;\n    }\n\n    this.handled_ = true;\n    if (this.queue_) {\n      this.queue_.clearUnhandledRejection(this);\n    }\n\n    var cb = new Task(\n        this.flow_,\n        this.invokeCallback_.bind(this, callback, errback),\n        name,\n        LONG_STACK_TRACES ? {name: 'Promise', top: fn} : undefined);\n    cb.promise.parent_ = this;\n\n    if (this.state_ !== PromiseState.PENDING &&\n        this.state_ !== PromiseState.BLOCKED) {\n      this.flow_.getActiveQueue_().enqueue(cb);\n    } else {\n      if (!this.callbacks_) {\n        this.callbacks_ = [];\n      }\n      this.callbacks_.push(cb);\n      cb.blocked = true;\n      this.flow_.getActiveQueue_().enqueue(cb);\n    }\n\n    return cb.promise;\n  }\n\n  /**\n   * Invokes a callback function attached to this promise.\n   * @param {(function(T): (R|IThenable<R>)|null|undefined)} callback The\n   *    fulfillment callback.\n   * @param {(function(*): (R|IThenable<R>)|null|undefined)} errback The\n   *    rejection callback.\n   * @template R\n   * @private\n   */\n  invokeCallback_(callback, errback) {\n    var callbackFn = callback;\n    if (this.state_ === PromiseState.REJECTED) {\n      callbackFn = errback;\n    }\n\n    if (typeof callbackFn === 'function') {\n      if (isGenerator(callbackFn)) {\n        return consume(callbackFn, null, this.value_);\n      }\n      return callbackFn(this.value_);\n    } else if (this.state_ === PromiseState.REJECTED) {\n      throw this.value_;\n    } else {\n      return this.value_;\n    }\n  }\n}\nCancellableThenable.addImplementation(ManagedPromise);\n\n\n/**\n * @param {!ManagedPromise} promise\n * @return {boolean}\n */\nfunction isPending(promise) {\n  return promise.state_ === PromiseState.PENDING;\n}\n\n\n/**\n * Structural interface for a deferred promise resolver.\n * @record\n * @template T\n */\nfunction Resolver() {}\n\n\n/**\n * The promised value for this resolver.\n * @type {!Thenable<T>}\n */\nResolver.prototype.promise;\n\n\n/**\n * Resolves the promised value with the given `value`.\n * @param {T|Thenable<T>} value\n * @return {void}\n */\nResolver.prototype.resolve;\n\n\n/**\n * Rejects the promised value with the given `reason`.\n * @param {*} reason\n * @return {void}\n */\nResolver.prototype.reject;\n\n\n/**\n * Represents a value that will be resolved at some point in the future. This\n * class represents the protected \"producer\" half of a ManagedPromise - each Deferred\n * has a {@code promise} property that may be returned to consumers for\n * registering callbacks, reserving the ability to resolve the deferred to the\n * producer.\n *\n * If this Deferred is rejected and there are no listeners registered before\n * the next turn of the event loop, the rejection will be passed to the\n * {@link ControlFlow} as an unhandled failure.\n *\n * @template T\n * @implements {Resolver<T>}\n */\nclass Deferred {\n  /**\n   * @param {ControlFlow=} opt_flow The control flow this instance was\n   *     created under. This should only be provided during unit tests.\n   * @param {?=} opt_skipLog An internal parameter used to skip logging the\n   *     creation of this promise. This parameter has no effect unless it is\n   *     strictly equal to an internal symbol. In other words, this parameter\n   *     is always ignored for external code.\n   */\n  constructor(opt_flow, opt_skipLog) {\n    var fulfill, reject;\n\n    /** @type {!ManagedPromise<T>} */\n    this.promise = new ManagedPromise(function(f, r) {\n      fulfill = f;\n      reject = r;\n    }, opt_flow, opt_skipLog);\n\n    var self = this;\n    var checkNotSelf = function(value) {\n      if (value === self) {\n        throw new TypeError('May not resolve a Deferred with itself');\n      }\n    };\n\n    /**\n     * Resolves this deferred with the given value. It is safe to call this as a\n     * normal function (with no bound \"this\").\n     * @param {(T|IThenable<T>|Thenable)=} opt_value The fulfilled value.\n     * @const\n     */\n    this.resolve = function(opt_value) {\n      checkNotSelf(opt_value);\n      fulfill(opt_value);\n    };\n\n    /**\n     * An alias for {@link #resolve}.\n     * @const\n     */\n    this.fulfill = this.resolve;\n\n    /**\n     * Rejects this promise with the given reason. It is safe to call this as a\n     * normal function (with no bound \"this\").\n     * @param {*=} opt_reason The rejection reason.\n     * @const\n     */\n    this.reject = function(opt_reason) {\n      checkNotSelf(opt_reason);\n      reject(opt_reason);\n    };\n  }\n}\n\n\n/**\n * Tests if a value is an Error-like object. This is more than an straight\n * instanceof check since the value may originate from another context.\n * @param {*} value The value to test.\n * @return {boolean} Whether the value is an error.\n */\nfunction isError(value) {\n  return value instanceof Error ||\n      (!!value && typeof value === 'object'\n          && typeof value.message === 'string');\n}\n\n\n/**\n * Determines whether a {@code value} should be treated as a promise.\n * Any object whose \"then\" property is a function will be considered a promise.\n *\n * @param {?} value The value to test.\n * @return {boolean} Whether the value is a promise.\n */\nfunction isPromise(value) {\n  try {\n    // Use array notation so the Closure compiler does not obfuscate away our\n    // contract.\n    return value\n        && (typeof value === 'object' || typeof value === 'function')\n        && typeof value['then'] === 'function';\n  } catch (ex) {\n    return false;\n  }\n}\n\n\n/**\n * Creates a promise that will be resolved at a set time in the future.\n * @param {number} ms The amount of time, in milliseconds, to wait before\n *     resolving the promise.\n * @return {!Thenable} The promise.\n */\nfunction delayed(ms) {\n  return createPromise(resolve => {\n    setTimeout(() => resolve(), ms);\n  });\n}\n\n\n/**\n * Creates a new deferred resolver.\n *\n * If the promise manager is currently enabled, this function will return a\n * {@link Deferred} instance. Otherwise, it will return a resolver for a\n * {@linkplain NativePromise native promise}.\n *\n * @return {!Resolver<T>} A new deferred resolver.\n * @template T\n */\nfunction defer() {\n  if (usePromiseManager()) {\n    return new Deferred();\n  }\n  let resolve, reject;\n  let promise = new NativePromise((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  return {promise, resolve, reject};\n}\n\n\n/**\n * Creates a promise that has been resolved with the given value.\n *\n * If the promise manager is currently enabled, this function will return a\n * {@linkplain ManagedPromise managed promise}. Otherwise, it will return a\n * {@linkplain NativePromise native promise}.\n *\n * @param {T=} opt_value The resolved value.\n * @return {!Thenable<T>} The resolved promise.\n * @template T\n */\nfunction fulfilled(opt_value) {\n  let ctor = usePromiseManager() ? ManagedPromise : NativePromise;\n  if (opt_value instanceof ctor) {\n    return /** @type {!Thenable} */(opt_value);\n  }\n\n  if (usePromiseManager()) {\n    // We can skip logging warnings about creating a managed promise because\n    // this function will automatically switch to use a native promise when\n    // the promise manager is disabled.\n    return new ManagedPromise(\n        resolve => resolve(opt_value), undefined, SKIP_LOG);\n  }\n  return NativePromise.resolve(opt_value);\n}\n\n\n/**\n * Creates a promise that has been rejected with the given reason.\n *\n * If the promise manager is currently enabled, this function will return a\n * {@linkplain ManagedPromise managed promise}. Otherwise, it will return a\n * {@linkplain NativePromise native promise}.\n *\n * @param {*=} opt_reason The rejection reason; may be any value, but is\n *     usually an Error or a string.\n * @return {!Thenable<?>} The rejected promise.\n */\nfunction rejected(opt_reason) {\n  if (usePromiseManager()) {\n    // We can skip logging warnings about creating a managed promise because\n    // this function will automatically switch to use a native promise when\n    // the promise manager is disabled.\n    return new ManagedPromise(\n        (_, reject) => reject(opt_reason), undefined, SKIP_LOG);\n  }\n  return NativePromise.reject(opt_reason);\n}\n\n\n/**\n * Wraps a function that expects a node-style callback as its final\n * argument. This callback expects two arguments: an error value (which will be\n * null if the call succeeded), and the success value as the second argument.\n * The callback will the resolve or reject the returned promise, based on its\n * arguments.\n * @param {!Function} fn The function to wrap.\n * @param {...?} var_args The arguments to apply to the function, excluding the\n *     final callback.\n * @return {!Thenable} A promise that will be resolved with the\n *     result of the provided function's callback.\n */\nfunction checkedNodeCall(fn, var_args) {\n  let args = Array.prototype.slice.call(arguments, 1);\n  return createPromise(function(fulfill, reject) {\n    try {\n      args.push(function(error, value) {\n        error ? reject(error) : fulfill(value);\n      });\n      fn.apply(undefined, args);\n    } catch (ex) {\n      reject(ex);\n    }\n  });\n}\n\n/**\n * Registers a listener to invoke when a promise is resolved, regardless\n * of whether the promise's value was successfully computed. This function\n * is synonymous with the {@code finally} clause in a synchronous API:\n *\n *     // Synchronous API:\n *     try {\n *       doSynchronousWork();\n *     } finally {\n *       cleanUp();\n *     }\n *\n *     // Asynchronous promise API:\n *     doAsynchronousWork().finally(cleanUp);\n *\n * __Note:__ similar to the {@code finally} clause, if the registered\n * callback returns a rejected promise or throws an error, it will silently\n * replace the rejection error (if any) from this promise:\n *\n *     try {\n *       throw Error('one');\n *     } finally {\n *       throw Error('two');  // Hides Error: one\n *     }\n *\n *     let p = Promise.reject(Error('one'));\n *     promise.finally(p, function() {\n *       throw Error('two');  // Hides Error: one\n *     });\n *\n * @param {!IThenable<?>} promise The promise to add the listener to.\n * @param {function(): (R|IThenable<R>)} callback The function to call when\n *     the promise is resolved.\n * @return {!IThenable<R>} A promise that will be resolved with the callback\n *     result.\n * @template R\n */\nfunction thenFinally(promise, callback) {\n  let error;\n  let mustThrow = false;\n  return promise.then(function() {\n    return callback();\n  }, function(err) {\n    error = err;\n    mustThrow = true;\n    return callback();\n  }).then(function() {\n    if (mustThrow) {\n      throw error;\n    }\n  });\n}\n\n\n/**\n * Registers an observer on a promised {@code value}, returning a new promise\n * that will be resolved when the value is. If {@code value} is not a promise,\n * then the return promise will be immediately resolved.\n * @param {*} value The value to observe.\n * @param {Function=} opt_callback The function to call when the value is\n *     resolved successfully.\n * @param {Function=} opt_errback The function to call when the value is\n *     rejected.\n * @return {!Thenable} A new promise.\n * @deprecated Use `promise.fulfilled(value).then(opt_callback, opt_errback)`\n */\nfunction when(value, opt_callback, opt_errback) {\n  return fulfilled(value).then(opt_callback, opt_errback);\n}\n\n\n/**\n * Invokes the appropriate callback function as soon as a promised `value` is\n * resolved.\n *\n * @param {*} value The value to observe.\n * @param {Function} callback The function to call when the value is\n *     resolved successfully.\n * @param {Function=} opt_errback The function to call when the value is\n *     rejected.\n */\nfunction asap(value, callback, opt_errback) {\n  if (isPromise(value)) {\n    value.then(callback, opt_errback);\n\n  } else if (callback) {\n    callback(value);\n  }\n}\n\n\n/**\n * Given an array of promises, will return a promise that will be fulfilled\n * with the fulfillment values of the input array's values. If any of the\n * input array's promises are rejected, the returned promise will be rejected\n * with the same reason.\n *\n * @param {!Array<(T|!ManagedPromise<T>)>} arr An array of\n *     promises to wait on.\n * @return {!Thenable<!Array<T>>} A promise that is\n *     fulfilled with an array containing the fulfilled values of the\n *     input array, or rejected with the same reason as the first\n *     rejected value.\n * @template T\n */\nfunction all(arr) {\n  return createPromise(function(fulfill, reject) {\n    var n = arr.length;\n    var values = [];\n\n    if (!n) {\n      fulfill(values);\n      return;\n    }\n\n    var toFulfill = n;\n    var onFulfilled = function(index, value) {\n      values[index] = value;\n      toFulfill--;\n      if (toFulfill == 0) {\n        fulfill(values);\n      }\n    };\n\n    function processPromise(index) {\n      asap(arr[index], function(value) {\n        onFulfilled(index, value);\n      }, reject);\n    }\n\n    for (var i = 0; i < n; ++i) {\n      processPromise(i);\n    }\n  });\n}\n\n\n/**\n * Calls a function for each element in an array and inserts the result into a\n * new array, which is used as the fulfillment value of the promise returned\n * by this function.\n *\n * If the return value of the mapping function is a promise, this function\n * will wait for it to be fulfilled before inserting it into the new array.\n *\n * If the mapping function throws or returns a rejected promise, the\n * promise returned by this function will be rejected with the same reason.\n * Only the first failure will be reported; all subsequent errors will be\n * silently ignored.\n *\n * @param {!(Array<TYPE>|ManagedPromise<!Array<TYPE>>)} arr The\n *     array to iterator over, or a promise that will resolve to said array.\n * @param {function(this: SELF, TYPE, number, !Array<TYPE>): ?} fn The\n *     function to call for each element in the array. This function should\n *     expect three arguments (the element, the index, and the array itself.\n * @param {SELF=} opt_self The object to be used as the value of 'this' within\n *     {@code fn}.\n * @template TYPE, SELF\n */\nfunction map(arr, fn, opt_self) {\n  return createPromise(resolve => resolve(arr)).then(v => {\n    if (!Array.isArray(v)) {\n      throw TypeError('not an array');\n    }\n    var arr = /** @type {!Array} */(v);\n    return createPromise(function(fulfill, reject) {\n      var n = arr.length;\n      var values = new Array(n);\n      (function processNext(i) {\n        for (; i < n; i++) {\n          if (i in arr) {\n            break;\n          }\n        }\n        if (i >= n) {\n          fulfill(values);\n          return;\n        }\n        try {\n          asap(\n              fn.call(opt_self, arr[i], i, /** @type {!Array} */(arr)),\n              function(value) {\n                values[i] = value;\n                processNext(i + 1);\n              },\n              reject);\n        } catch (ex) {\n          reject(ex);\n        }\n      })(0);\n    });\n  });\n}\n\n\n/**\n * Calls a function for each element in an array, and if the function returns\n * true adds the element to a new array.\n *\n * If the return value of the filter function is a promise, this function\n * will wait for it to be fulfilled before determining whether to insert the\n * element into the new array.\n *\n * If the filter function throws or returns a rejected promise, the promise\n * returned by this function will be rejected with the same reason. Only the\n * first failure will be reported; all subsequent errors will be silently\n * ignored.\n *\n * @param {!(Array<TYPE>|ManagedPromise<!Array<TYPE>>)} arr The\n *     array to iterator over, or a promise that will resolve to said array.\n * @param {function(this: SELF, TYPE, number, !Array<TYPE>): (\n *             boolean|ManagedPromise<boolean>)} fn The function\n *     to call for each element in the array.\n * @param {SELF=} opt_self The object to be used as the value of 'this' within\n *     {@code fn}.\n * @template TYPE, SELF\n */\nfunction filter(arr, fn, opt_self) {\n  return createPromise(resolve => resolve(arr)).then(v => {\n    if (!Array.isArray(v)) {\n      throw TypeError('not an array');\n    }\n    var arr = /** @type {!Array} */(v);\n    return createPromise(function(fulfill, reject) {\n      var n = arr.length;\n      var values = [];\n      var valuesLength = 0;\n      (function processNext(i) {\n        for (; i < n; i++) {\n          if (i in arr) {\n            break;\n          }\n        }\n        if (i >= n) {\n          fulfill(values);\n          return;\n        }\n        try {\n          var value = arr[i];\n          var include = fn.call(opt_self, value, i, /** @type {!Array} */(arr));\n          asap(include, function(include) {\n            if (include) {\n              values[valuesLength++] = value;\n            }\n            processNext(i + 1);\n            }, reject);\n        } catch (ex) {\n          reject(ex);\n        }\n      })(0);\n    });\n  });\n}\n\n\n/**\n * Returns a promise that will be resolved with the input value in a\n * fully-resolved state. If the value is an array, each element will be fully\n * resolved. Likewise, if the value is an object, all keys will be fully\n * resolved. In both cases, all nested arrays and objects will also be\n * fully resolved.  All fields are resolved in place; the returned promise will\n * resolve on {@code value} and not a copy.\n *\n * Warning: This function makes no checks against objects that contain\n * cyclical references:\n *\n *     var value = {};\n *     value['self'] = value;\n *     promise.fullyResolved(value);  // Stack overflow.\n *\n * @param {*} value The value to fully resolve.\n * @return {!Thenable} A promise for a fully resolved version\n *     of the input value.\n */\nfunction fullyResolved(value) {\n  if (isPromise(value)) {\n    return fulfilled(value).then(fullyResolveValue);\n  }\n  return fullyResolveValue(value);\n}\n\n\n/**\n * @param {*} value The value to fully resolve. If a promise, assumed to\n *     already be resolved.\n * @return {!Thenable} A promise for a fully resolved version\n *     of the input value.\n */\nfunction fullyResolveValue(value) {\n  if (Array.isArray(value)) {\n    return fullyResolveKeys(/** @type {!Array} */ (value));\n  }\n\n  if (isPromise(value)) {\n    if (isPromise(value)) {\n      // We get here when the original input value is a promise that\n      // resolves to itself. When the user provides us with such a promise,\n      // trust that it counts as a \"fully resolved\" value and return it.\n      // Of course, since it's already a promise, we can just return it\n      // to the user instead of wrapping it in another promise.\n      return /** @type {!ManagedPromise} */ (value);\n    }\n  }\n\n  if (value && typeof value === 'object') {\n    return fullyResolveKeys(/** @type {!Object} */ (value));\n  }\n\n  if (typeof value === 'function') {\n    return fullyResolveKeys(/** @type {!Object} */ (value));\n  }\n\n  return createPromise(resolve => resolve(value));\n}\n\n\n/**\n * @param {!(Array|Object)} obj the object to resolve.\n * @return {!Thenable} A promise that will be resolved with the\n *     input object once all of its values have been fully resolved.\n */\nfunction fullyResolveKeys(obj) {\n  var isArray = Array.isArray(obj);\n  var numKeys = isArray ? obj.length : (function() {\n    let n = 0;\n    for (let key in obj) {\n      n += 1;\n    }\n    return n;\n  })();\n\n  if (!numKeys) {\n    return createPromise(resolve => resolve(obj));\n  }\n\n  function forEachProperty(obj, fn) {\n    for (let key in obj) {\n      fn.call(null, obj[key], key, obj);\n    }\n  }\n\n  function forEachElement(arr, fn) {\n    arr.forEach(fn);\n  }\n\n  var numResolved = 0;\n  return createPromise(function(fulfill, reject) {\n    var forEachKey = isArray ? forEachElement: forEachProperty;\n\n    forEachKey(obj, function(partialValue, key) {\n      if (!Array.isArray(partialValue)\n          && (!partialValue || typeof partialValue !== 'object')) {\n        maybeResolveValue();\n        return;\n      }\n\n      fullyResolved(partialValue).then(\n          function(resolvedValue) {\n            obj[key] = resolvedValue;\n            maybeResolveValue();\n          },\n          reject);\n    });\n\n    function maybeResolveValue() {\n      if (++numResolved == numKeys) {\n        fulfill(obj);\n      }\n    }\n  });\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  ControlFlow\n//\n//////////////////////////////////////////////////////////////////////////////\n\n\n/**\n * Defines methods for coordinating the execution of asynchronous tasks.\n * @record\n */\nclass Scheduler {\n  /**\n   * Schedules a task for execution. If the task function is a generator, the\n   * task will be executed using {@link ./promise.consume consume()}.\n   *\n   * @param {function(): (T|IThenable<T>)} fn The function to call to start the\n   *     task.\n   * @param {string=} opt_description A description of the task for debugging\n   *     purposes.\n   * @return {!Thenable<T>} A promise that will be resolved with the task\n   *     result.\n   * @template T\n   */\n  execute(fn, opt_description) {}\n\n  /**\n   * Creates a new promise using the given resolver function.\n   *\n   * @param {function(\n   *             function((T|IThenable<T>|Thenable|null)=),\n   *             function(*=))} resolver\n   * @return {!Thenable<T>}\n   * @template T\n   */\n  promise(resolver) {}\n\n  /**\n   * Schedules a `setTimeout` call.\n   *\n   * @param {number} ms The timeout delay, in milliseconds.\n   * @param {string=} opt_description A description to accompany the timeout.\n   * @return {!Thenable<void>} A promise that will be resolved when the timeout\n   *     fires.\n   */\n  timeout(ms, opt_description) {}\n\n  /**\n   * Schedules a task to wait for a condition to hold.\n   *\n   * If the condition is defined as a function, it may return any value. Promise\n   * will be resolved before testing if the condition holds (resolution time\n   * counts towards the timeout). Once resolved, values are always evaluated as\n   * booleans.\n   *\n   * If the condition function throws, or returns a rejected promise, the\n   * wait task will fail.\n   *\n   * If the condition is defined as a promise, the scheduler will wait for it to\n   * settle. If the timeout expires before the promise settles, the promise\n   * returned by this function will be rejected.\n   *\n   * If this function is invoked with `timeout === 0`, or the timeout is\n   * omitted, this scheduler will wait indefinitely for the condition to be\n   * satisfied.\n   *\n   * @param {(!IThenable<T>|function())} condition The condition to poll,\n   *     or a promise to wait on.\n   * @param {number=} opt_timeout How long to wait, in milliseconds, for the\n   *     condition to hold before timing out. If omitted, the flow will wait\n   *     indefinitely.\n   * @param {string=} opt_message An optional error message to include if the\n   *     wait times out; defaults to the empty string.\n   * @return {!Thenable<T>} A promise that will be fulfilled\n   *     when the condition has been satisfied. The promise shall be rejected\n   *     if the wait times out waiting for the condition.\n   * @throws {TypeError} If condition is not a function or promise or if timeout\n   *     is not a number >= 0.\n   * @template T\n   */\n  wait(condition, opt_timeout, opt_message) {}\n}\n\n\nlet USE_PROMISE_MANAGER;\nfunction usePromiseManager() {\n  if (typeof USE_PROMISE_MANAGER !== 'undefined') {\n    return !!USE_PROMISE_MANAGER;\n  }\n  return process.env['SELENIUM_PROMISE_MANAGER'] === undefined\n      || !/^0|false$/i.test(process.env['SELENIUM_PROMISE_MANAGER']);\n}\n\n\n/**\n * Creates a new promise with the given `resolver` function. If the promise\n * manager is currently enabled, the returned promise will be a\n * {@linkplain ManagedPromise} instance. Otherwise, it will be a native promise.\n *\n * @param {function(\n *             function((T|IThenable<T>|Thenable|null)=),\n *             function(*=))} resolver\n * @return {!Thenable<T>}\n * @template T\n */\nfunction createPromise(resolver) {\n  let ctor = usePromiseManager() ? ManagedPromise : NativePromise;\n  return new ctor(resolver);\n}\n\n\n/**\n * @param {!Scheduler} scheduler The scheduler to use.\n * @param {(!IThenable<T>|function())} condition The condition to poll,\n *     or a promise to wait on.\n * @param {number=} opt_timeout How long to wait, in milliseconds, for the\n *     condition to hold before timing out. If omitted, the flow will wait\n *     indefinitely.\n * @param {string=} opt_message An optional error message to include if the\n *     wait times out; defaults to the empty string.\n * @return {!Thenable<T>} A promise that will be fulfilled\n *     when the condition has been satisfied. The promise shall be rejected\n *     if the wait times out waiting for the condition.\n * @throws {TypeError} If condition is not a function or promise or if timeout\n *     is not a number >= 0.\n * @template T\n */\nfunction scheduleWait(scheduler, condition, opt_timeout, opt_message) {\n  let timeout = opt_timeout || 0;\n  if (typeof timeout !== 'number' || timeout < 0) {\n    throw TypeError('timeout must be a number >= 0: ' + timeout);\n  }\n\n  if (isPromise(condition)) {\n    return scheduler.execute(function() {\n      if (!timeout) {\n        return condition;\n      }\n      return scheduler.promise(function(fulfill, reject) {\n        let start = Date.now();\n        let timer = setTimeout(function() {\n          timer = null;\n          reject(\n              new error.TimeoutError(\n                  (opt_message ? opt_message + '\\n' : '')\n                      + 'Timed out waiting for promise to resolve after '\n                      + (Date.now() - start) + 'ms'));\n        }, timeout);\n\n        /** @type {Thenable} */(condition).then(\n          function(value) {\n            timer && clearTimeout(timer);\n            fulfill(value);\n          },\n          function(error) {\n            timer && clearTimeout(timer);\n            reject(error);\n          });\n      });\n    }, opt_message || '<anonymous wait: promise resolution>');\n  }\n\n  if (typeof condition !== 'function') {\n    throw TypeError('Invalid condition; must be a function or promise: ' +\n        typeof condition);\n  }\n\n  if (isGenerator(condition)) {\n    let original = condition;\n    condition = () => consume(original);\n  }\n\n  return scheduler.execute(function() {\n    var startTime = Date.now();\n    return scheduler.promise(function(fulfill, reject) {\n      pollCondition();\n\n      function pollCondition() {\n        var conditionFn = /** @type {function()} */(condition);\n        scheduler.execute(conditionFn).then(function(value) {\n          var elapsed = Date.now() - startTime;\n          if (!!value) {\n            fulfill(value);\n          } else if (timeout && elapsed >= timeout) {\n            reject(\n                new error.TimeoutError(\n                    (opt_message ? opt_message + '\\n' : '')\n                        + `Wait timed out after ${elapsed}ms`));\n          } else {\n            // Do not use asyncRun here because we need a non-micro yield\n            // here so the UI thread is given a chance when running in a\n            // browser.\n            setTimeout(pollCondition, 0);\n          }\n        }, reject);\n      }\n    });\n  }, opt_message || '<anonymous wait>');\n}\n\n\n/**\n * A scheduler that executes all tasks immediately, with no coordination. This\n * class is an event emitter for API compatibility with the {@link ControlFlow},\n * however, it emits no events.\n *\n * @implements {Scheduler}\n */\nclass SimpleScheduler extends events.EventEmitter {\n  /** @override */\n  execute(fn) {\n    return this.promise((resolve, reject) => {\n      try {\n        if (isGenerator(fn)) {\n          consume(fn).then(resolve, reject);\n        } else {\n          resolve(fn.call(undefined));\n        }\n      } catch (ex) {\n        reject(ex);\n      }\n    });\n  }\n\n  /** @override */\n  promise(resolver) {\n    return new NativePromise(resolver);\n  }\n\n  /** @override */\n  timeout(ms) {\n    return this.promise(resolve => setTimeout(_ => resolve(), ms));\n  }\n\n  /** @override */\n  wait(condition, opt_timeout, opt_message) {\n    return scheduleWait(this, condition, opt_timeout, opt_message);\n  }\n}\nconst SIMPLE_SCHEDULER = new SimpleScheduler;\n\n\n/**\n * Handles the execution of scheduled tasks, each of which may be an\n * asynchronous operation. The control flow will ensure tasks are executed in\n * the order scheduled, starting each task only once those before it have\n * completed.\n *\n * Each task scheduled within this flow may return a {@link ManagedPromise} to\n * indicate it is an asynchronous operation. The ControlFlow will wait for such\n * promises to be resolved before marking the task as completed.\n *\n * Tasks and each callback registered on a {@link ManagedPromise} will be run\n * in their own ControlFlow frame. Any tasks scheduled within a frame will take\n * priority over previously scheduled tasks. Furthermore, if any of the tasks in\n * the frame fail, the remainder of the tasks in that frame will be discarded\n * and the failure will be propagated to the user through the callback/task's\n * promised result.\n *\n * Each time a ControlFlow empties its task queue, it will fire an\n * {@link ControlFlow.EventType.IDLE IDLE} event. Conversely, whenever\n * the flow terminates due to an unhandled error, it will remove all\n * remaining tasks in its queue and fire an\n * {@link ControlFlow.EventType.UNCAUGHT_EXCEPTION UNCAUGHT_EXCEPTION} event.\n * If there are no listeners registered with the flow, the error will be\n * rethrown to the global error handler.\n *\n * Refer to the {@link ./promise} module documentation for a detailed\n * explanation of how the ControlFlow coordinates task execution.\n *\n * @implements {Scheduler}\n * @final\n */\nclass ControlFlow extends events.EventEmitter {\n  constructor() {\n    if (!usePromiseManager()) {\n      throw TypeError(\n          'Cannot instantiate control flow when the promise manager has'\n              + ' been disabled');\n    }\n\n    super();\n\n    /** @private {boolean} */\n    this.propagateUnhandledRejections_ = true;\n\n    /** @private {TaskQueue} */\n    this.activeQueue_ = null;\n\n    /** @private {Set<TaskQueue>} */\n    this.taskQueues_ = null;\n\n    /**\n     * Microtask that controls shutting down the control flow. Upon shut down,\n     * the flow will emit an\n     * {@link ControlFlow.EventType.IDLE} event. Idle events\n     * always follow a brief timeout in order to catch latent errors from the\n     * last completed task. If this task had a callback registered, but no\n     * errback, and the task fails, the unhandled failure would not be reported\n     * by the promise system until the next turn of the event loop:\n     *\n     *   // Schedule 1 task that fails.\n     *   var result = promise.controlFlow().execute(\n     *       () => promise.rejected('failed'), 'example');\n     *   // Set a callback on the result. This delays reporting the unhandled\n     *   // failure for 1 turn of the event loop.\n     *   result.then(function() {});\n     *\n     * @private {MicroTask}\n     */\n    this.shutdownTask_ = null;\n\n    /**\n     * ID for a long running interval used to keep a Node.js process running\n     * while a control flow's event loop is still working. This is a cheap hack\n     * required since JS events are only scheduled to run when there is\n     * _actually_ something to run. When a control flow is waiting on a task,\n     * there will be nothing in the JS event loop and the process would\n     * terminate without this.\n     * @private\n     */\n    this.hold_ = null;\n  }\n\n  /**\n   * Returns a string representation of this control flow, which is its current\n   * {@linkplain #getSchedule() schedule}, sans task stack traces.\n   * @return {string} The string representation of this control flow.\n   * @override\n   */\n  toString() {\n    return this.getSchedule();\n  }\n\n  /**\n   * Sets whether any unhandled rejections should propagate up through the\n   * control flow stack and cause rejections within parent tasks. If error\n   * propagation is disabled, tasks will not be aborted when an unhandled\n   * promise rejection is detected, but the rejection _will_ trigger an\n   * {@link ControlFlow.EventType.UNCAUGHT_EXCEPTION} event.\n   *\n   * The default behavior is to propagate all unhandled rejections. _The use\n   * of this option is highly discouraged._\n   *\n   * @param {boolean} propagate whether to propagate errors.\n   */\n  setPropagateUnhandledRejections(propagate) {\n    this.propagateUnhandledRejections_ = propagate;\n  }\n\n  /**\n   * @return {boolean} Whether this flow is currently idle.\n   */\n  isIdle() {\n    return !this.shutdownTask_ && (!this.taskQueues_ || !this.taskQueues_.size);\n  }\n\n  /**\n   * Resets this instance, clearing its queue and removing all event listeners.\n   */\n  reset() {\n    this.cancelQueues_(new FlowResetError);\n    this.emit(ControlFlow.EventType.RESET);\n    this.removeAllListeners();\n    this.cancelShutdown_();\n  }\n\n  /**\n   * Generates an annotated string describing the internal state of this control\n   * flow, including the currently executing as well as pending tasks. If\n   * {@code opt_includeStackTraces === true}, the string will include the\n   * stack trace from when each task was scheduled.\n   * @param {string=} opt_includeStackTraces Whether to include the stack traces\n   * from when each task was scheduled. Defaults to false.\n   * @return {string} String representation of this flow's internal state.\n   */\n  getSchedule(opt_includeStackTraces) {\n    var ret = 'ControlFlow::' + getUid(this);\n    var activeQueue = this.activeQueue_;\n    if (!this.taskQueues_ || !this.taskQueues_.size) {\n      return ret;\n    }\n    var childIndent = '| ';\n    for (var q of this.taskQueues_) {\n      ret += '\\n' + printQ(q, childIndent);\n    }\n    return ret;\n\n    function printQ(q, indent) {\n      var ret = q.toString();\n      if (q === activeQueue) {\n        ret = '(active) ' + ret;\n      }\n      var prefix = indent + childIndent;\n      if (q.pending_) {\n        if (q.pending_.q.state_ !== TaskQueueState.FINISHED) {\n          ret += '\\n' + prefix + '(pending) ' + q.pending_.task;\n          ret += '\\n' + printQ(q.pending_.q, prefix + childIndent);\n        } else {\n          ret += '\\n' + prefix + '(blocked) ' + q.pending_.task;\n        }\n      }\n      if (q.interrupts_) {\n        q.interrupts_.forEach((task) => {\n          ret += '\\n' + prefix + task;\n        });\n      }\n      if (q.tasks_) {\n        q.tasks_.forEach((task) => ret += printTask(task, '\\n' + prefix));\n      }\n      return indent + ret;\n    }\n\n    function printTask(task, prefix) {\n      var ret = prefix + task;\n      if (opt_includeStackTraces && task.promise.stack_) {\n        ret += prefix + childIndent\n            + (task.promise.stack_.stack || task.promise.stack_)\n                  .replace(/\\n/g, prefix);\n      }\n      return ret;\n    }\n  }\n\n  /**\n   * Returns the currently active task queue for this flow. If there is no\n   * active queue, one will be created.\n   * @return {!TaskQueue} the currently active task queue for this flow.\n   * @private\n   */\n  getActiveQueue_() {\n    if (this.activeQueue_) {\n      return this.activeQueue_;\n    }\n\n    this.activeQueue_ = new TaskQueue(this);\n    if (!this.taskQueues_) {\n      this.taskQueues_ = new Set();\n    }\n    this.taskQueues_.add(this.activeQueue_);\n    this.activeQueue_\n        .once('end', this.onQueueEnd_, this)\n        .once('error', this.onQueueError_, this);\n\n    asyncRun(() => this.activeQueue_ = null);\n    this.activeQueue_.start();\n    return this.activeQueue_;\n  }\n\n  /** @override */\n  execute(fn, opt_description) {\n    if (isGenerator(fn)) {\n      let original = fn;\n      fn = () => consume(original);\n    }\n\n    if (!this.hold_) {\n      let holdIntervalMs = 2147483647;  // 2^31-1; max timer length for Node.js\n      this.hold_ = setInterval(function() {}, holdIntervalMs);\n    }\n\n    let task = new Task(\n        this, fn, opt_description || '<anonymous>',\n        {name: 'Task', top: ControlFlow.prototype.execute},\n        true);\n\n    let q = this.getActiveQueue_();\n\n    for (let i = q.tasks_.length; i > 0; i--) {\n      let previousTask = q.tasks_[i - 1];\n      if (previousTask.userTask_) {\n        FLOW_LOG.warning(() => {\n          return `Detected scheduling of an unchained task.\nWhen the promise manager is disabled, unchained tasks will not wait for\npreviously scheduled tasks to finish before starting to execute.\nNew task: ${task.promise.stack_.stack}\nPrevious task: ${previousTask.promise.stack_.stack}`.split(/\\n/).join('\\n    ');\n        });\n        break;\n      }\n    }\n\n    q.enqueue(task);\n    this.emit(ControlFlow.EventType.SCHEDULE_TASK, task.description);\n    return task.promise;\n  }\n\n  /** @override */\n  promise(resolver) {\n    return new ManagedPromise(resolver, this, SKIP_LOG);\n  }\n\n  /** @override */\n  timeout(ms, opt_description) {\n    return this.execute(() => {\n      return this.promise(resolve => setTimeout(() => resolve(), ms));\n    }, opt_description);\n  }\n\n  /** @override */\n  wait(condition, opt_timeout, opt_message) {\n    return scheduleWait(this, condition, opt_timeout, opt_message);\n  }\n\n  /**\n   * Executes a function in the next available turn of the JavaScript event\n   * loop. This ensures the function runs with its own task queue and any\n   * scheduled tasks will run in \"parallel\" to those scheduled in the current\n   * function.\n   *\n   *     flow.execute(() => console.log('a'));\n   *     flow.execute(() => console.log('b'));\n   *     flow.execute(() => console.log('c'));\n   *     flow.async(() => {\n   *        flow.execute(() => console.log('d'));\n   *        flow.execute(() => console.log('e'));\n   *     });\n   *     flow.async(() => {\n   *        flow.execute(() => console.log('f'));\n   *        flow.execute(() => console.log('g'));\n   *     });\n   *     flow.once('idle', () => console.log('fin'));\n   *     // a\n   *     // d\n   *     // f\n   *     // b\n   *     // e\n   *     // g\n   *     // c\n   *     // fin\n   *\n   * If the function itself throws, the error will be treated the same as an\n   * unhandled rejection within the control flow.\n   *\n   * __NOTE__: This function is considered _unstable_.\n   *\n   * @param {!Function} fn The function to execute.\n   * @param {Object=} opt_self The object in whose context to run the function.\n   * @param {...*} var_args Any arguments to pass to the function.\n   */\n  async(fn, opt_self, var_args) {\n    asyncRun(() => {\n      // Clear any lingering queues, forces getActiveQueue_ to create a new one.\n      this.activeQueue_ = null;\n      var q = this.getActiveQueue_();\n      try {\n        q.execute_(fn.bind(opt_self, var_args));\n      } catch (ex) {\n        var cancellationError = CancellationError.wrap(ex,\n            'Function passed to ControlFlow.async() threw');\n        cancellationError.silent_ = true;\n        q.abort_(cancellationError);\n      } finally {\n        this.activeQueue_ = null;\n      }\n    });\n  }\n\n  /**\n   * Event handler for when a task queue is exhausted. This starts the shutdown\n   * sequence for this instance if there are no remaining task queues: after\n   * one turn of the event loop, this object will emit the\n   * {@link ControlFlow.EventType.IDLE IDLE} event to signal\n   * listeners that it has completed. During this wait, if another task is\n   * scheduled, the shutdown will be aborted.\n   *\n   * @param {!TaskQueue} q the completed task queue.\n   * @private\n   */\n  onQueueEnd_(q) {\n    if (!this.taskQueues_) {\n      return;\n    }\n    this.taskQueues_.delete(q);\n\n    vlog(1, () => q + ' has finished');\n    vlog(1, () => this.taskQueues_.size + ' queues remain\\n' + this, this);\n\n    if (!this.taskQueues_.size) {\n      if (this.shutdownTask_) {\n        throw Error('Already have a shutdown task??');\n      }\n      vlog(1, () => 'Scheduling shutdown\\n' + this);\n      this.shutdownTask_ = new MicroTask(() => this.shutdown_());\n    }\n  }\n\n  /**\n   * Event handler for when a task queue terminates with an error. This triggers\n   * the cancellation of all other task queues and a\n   * {@link ControlFlow.EventType.UNCAUGHT_EXCEPTION} event.\n   * If there are no error event listeners registered with this instance, the\n   * error will be rethrown to the global error handler.\n   *\n   * @param {*} error the error that caused the task queue to terminate.\n   * @param {!TaskQueue} q the task queue.\n   * @private\n   */\n  onQueueError_(error, q) {\n    if (this.taskQueues_) {\n      this.taskQueues_.delete(q);\n    }\n    this.cancelQueues_(CancellationError.wrap(\n        error, 'There was an uncaught error in the control flow'));\n    this.cancelShutdown_();\n    this.cancelHold_();\n\n    setTimeout(() => {\n      let listeners = this.listeners(ControlFlow.EventType.UNCAUGHT_EXCEPTION);\n      if (!listeners.size) {\n        throw error;\n      } else {\n        this.reportUncaughtException_(error);\n      }\n    }, 0);\n  }\n\n  /**\n   * Cancels all remaining task queues.\n   * @param {!CancellationError} reason The cancellation reason.\n   * @private\n   */\n  cancelQueues_(reason) {\n    reason.silent_ = true;\n    if (this.taskQueues_) {\n      for (var q of this.taskQueues_) {\n        q.removeAllListeners();\n        q.abort_(reason);\n      }\n      this.taskQueues_.clear();\n      this.taskQueues_ = null;\n    }\n  }\n\n  /**\n   * Reports an uncaught exception using a\n   * {@link ControlFlow.EventType.UNCAUGHT_EXCEPTION} event.\n   *\n   * @param {*} e the error to report.\n   * @private\n   */\n  reportUncaughtException_(e) {\n    this.emit(ControlFlow.EventType.UNCAUGHT_EXCEPTION, e);\n  }\n\n  /** @private */\n  cancelHold_() {\n    if (this.hold_) {\n      clearInterval(this.hold_);\n      this.hold_ = null;\n    }\n  }\n\n  /** @private */\n  shutdown_() {\n    vlog(1, () => 'Going idle: ' + this);\n    this.cancelHold_();\n    this.shutdownTask_ = null;\n    this.emit(ControlFlow.EventType.IDLE);\n  }\n\n  /**\n   * Cancels the shutdown sequence if it is currently scheduled.\n   * @private\n   */\n  cancelShutdown_() {\n    if (this.shutdownTask_) {\n      this.shutdownTask_.cancel();\n      this.shutdownTask_ = null;\n    }\n  }\n}\n\n\n/**\n * Events that may be emitted by an {@link ControlFlow}.\n * @enum {string}\n */\nControlFlow.EventType = {\n\n  /** Emitted when all tasks have been successfully executed. */\n  IDLE: 'idle',\n\n  /** Emitted when a ControlFlow has been reset. */\n  RESET: 'reset',\n\n  /** Emitted whenever a new task has been scheduled. */\n  SCHEDULE_TASK: 'scheduleTask',\n\n  /**\n   * Emitted whenever a control flow aborts due to an unhandled promise\n   * rejection. This event will be emitted along with the offending rejection\n   * reason. Upon emitting this event, the control flow will empty its task\n   * queue and revert to its initial state.\n   */\n  UNCAUGHT_EXCEPTION: 'uncaughtException'\n};\n\n\n/**\n * Wraps a function to execute as a cancellable micro task.\n * @final\n */\nclass MicroTask {\n  /**\n   * @param {function()} fn The function to run as a micro task.\n   */\n  constructor(fn) {\n    /** @private {boolean} */\n    this.cancelled_ = false;\n    asyncRun(() => {\n      if (!this.cancelled_) {\n        fn();\n      }\n    });\n  }\n\n  /**\n   * Runs the given function after a microtask yield.\n   * @param {function()} fn The function to run.\n   */\n  static run(fn) {\n    NativePromise.resolve().then(function() {\n      try {\n        fn();\n      } catch (ignored) {\n        // Do nothing.\n      }\n    });\n  }\n\n  /**\n   * Cancels the execution of this task. Note: this will not prevent the task\n   * timer from firing, just the invocation of the wrapped function.\n   */\n  cancel() {\n    this.cancelled_ = true;\n  }\n}\n\n\n/**\n * A task to be executed by a {@link ControlFlow}.\n *\n * @template T\n * @final\n */\nclass Task extends Deferred {\n  /**\n   * @param {!ControlFlow} flow The flow this instances belongs\n   *     to.\n   * @param {function(): (T|!ManagedPromise<T>)} fn The function to\n   *     call when the task executes. If it returns a\n   *     {@link ManagedPromise}, the flow will wait for it to be\n   *     resolved before starting the next task.\n   * @param {string} description A description of the task for debugging.\n   * @param {{name: string, top: !Function}=} opt_stackOptions Options to use\n   *     when capturing the stacktrace for when this task was created.\n   * @param {boolean=} opt_isUserTask Whether this task was explicitly scheduled\n   *     by the use of the promise manager.\n   */\n  constructor(flow, fn, description, opt_stackOptions, opt_isUserTask) {\n    super(flow, SKIP_LOG);\n    getUid(this);\n\n    /** @type {function(): (T|!ManagedPromise<T>)} */\n    this.execute = fn;\n\n    /** @type {string} */\n    this.description = description;\n\n    /** @type {TaskQueue} */\n    this.queue = null;\n\n    /** @private @const {boolean} */\n    this.userTask_ = !!opt_isUserTask;\n\n    /**\n     * Whether this task is considered block. A blocked task may be registered\n     * in a task queue, but will be dropped if it is still blocked when it\n     * reaches the front of the queue. A dropped task may always be rescheduled.\n     *\n     * Blocked tasks are used when a callback is attached to an unsettled\n     * promise to reserve a spot in line (in a manner of speaking). If the\n     * promise is not settled before the callback reaches the front of the\n     * of the queue, it will be dropped. Once the promise is settled, the\n     * dropped task will be rescheduled as an interrupt on the currently task\n     * queue.\n     *\n     * @type {boolean}\n     */\n    this.blocked = false;\n\n    if (opt_stackOptions) {\n      this.promise.stack_ = captureStackTrace(\n          opt_stackOptions.name, this.description, opt_stackOptions.top);\n    }\n  }\n\n  /** @override */\n  toString() {\n    return 'Task::' + getUid(this) + '<' + this.description + '>';\n  }\n}\n\n\n/** @enum {string} */\nconst TaskQueueState = {\n  NEW: 'new',\n  STARTED: 'started',\n  FINISHED: 'finished'\n};\n\n\n/**\n * @final\n */\nclass TaskQueue extends events.EventEmitter {\n  /** @param {!ControlFlow} flow . */\n  constructor(flow) {\n    super();\n\n    /** @private {string} */\n    this.name_ = 'TaskQueue::' + getUid(this);\n\n    /** @private {!ControlFlow} */\n    this.flow_ = flow;\n\n    /** @private {!Array<!Task>} */\n    this.tasks_ = [];\n\n    /** @private {Array<!Task>} */\n    this.interrupts_ = null;\n\n    /** @private {({task: !Task, q: !TaskQueue}|null)} */\n    this.pending_ = null;\n\n    /** @private {TaskQueue} */\n    this.subQ_ = null;\n\n    /** @private {TaskQueueState} */\n    this.state_ = TaskQueueState.NEW;\n\n    /** @private {!Set<!ManagedPromise>} */\n    this.unhandledRejections_ = new Set();\n  }\n\n  /** @override */\n  toString() {\n    return 'TaskQueue::' + getUid(this);\n  }\n\n  /**\n   * @param {!ManagedPromise} promise .\n   */\n  addUnhandledRejection(promise) {\n    // TODO: node 4.0.0+\n    vlog(2, () => this + ' registering unhandled rejection: ' + promise, this);\n    this.unhandledRejections_.add(promise);\n  }\n\n  /**\n   * @param {!ManagedPromise} promise .\n   */\n  clearUnhandledRejection(promise) {\n    var deleted = this.unhandledRejections_.delete(promise);\n    if (deleted) {\n      // TODO: node 4.0.0+\n      vlog(2, () => this + ' clearing unhandled rejection: ' + promise, this);\n    }\n  }\n\n  /**\n   * Enqueues a new task for execution.\n   * @param {!Task} task The task to enqueue.\n   * @throws {Error} If this instance has already started execution.\n   */\n  enqueue(task) {\n    if (this.state_ !== TaskQueueState.NEW) {\n      throw Error('TaskQueue has started: ' + this);\n    }\n\n    if (task.queue) {\n      throw Error('Task is already scheduled in another queue');\n    }\n\n    this.tasks_.push(task);\n    task.queue = this;\n    ON_CANCEL_HANDLER.set(\n        task.promise,\n        (e) => this.onTaskCancelled_(task, e));\n\n    vlog(1, () => this + '.enqueue(' + task + ')', this);\n    vlog(2, () => this.flow_.toString(), this);\n  }\n\n  /**\n   * Schedules the callbacks registered on the given promise in this queue.\n   *\n   * @param {!ManagedPromise} promise the promise whose callbacks should be\n   *     registered as interrupts in this task queue.\n   * @throws {Error} if this queue has already finished.\n   */\n  scheduleCallbacks(promise) {\n    if (this.state_ === TaskQueueState.FINISHED) {\n      throw new Error('cannot interrupt a finished q(' + this + ')');\n    }\n\n    if (this.pending_ && this.pending_.task.promise === promise) {\n      this.pending_.task.promise.queue_ = null;\n      this.pending_ = null;\n      asyncRun(() => this.executeNext_());\n    }\n\n    if (!promise.callbacks_) {\n      return;\n    }\n    promise.callbacks_.forEach(function(cb) {\n      cb.blocked = false;\n      if (cb.queue) {\n        return;\n      }\n\n      ON_CANCEL_HANDLER.set(\n          cb.promise,\n          (e) => this.onTaskCancelled_(cb, e));\n\n      if (cb.queue === this && this.tasks_.indexOf(cb) !== -1) {\n        return;\n      }\n\n      if (cb.queue) {\n        cb.queue.dropTask_(cb);\n      }\n\n      cb.queue = this;\n      if (!this.interrupts_) {\n        this.interrupts_ = [];\n      }\n      this.interrupts_.push(cb);\n    }, this);\n    promise.callbacks_ = null;\n    vlog(2, () => this + ' interrupted\\n' + this.flow_, this);\n  }\n\n  /**\n   * Starts executing tasks in this queue. Once called, no further tasks may\n   * be {@linkplain #enqueue() enqueued} with this instance.\n   *\n   * @throws {Error} if this queue has already been started.\n   */\n  start() {\n    if (this.state_ !== TaskQueueState.NEW) {\n      throw new Error('TaskQueue has already started');\n    }\n    // Always asynchronously execute next, even if there doesn't look like\n    // there is anything in the queue. This will catch pending unhandled\n    // rejections that were registered before start was called.\n    asyncRun(() => this.executeNext_());\n  }\n\n  /**\n   * Aborts this task queue. If there are any scheduled tasks, they are silently\n   * cancelled and discarded (their callbacks will never fire). If this queue\n   * has a _pending_ task, the abortion error is used to cancel that task.\n   * Otherwise, this queue will emit an error event.\n   *\n   * @param {*} error The abortion reason.\n   * @private\n   */\n  abort_(error) {\n    var cancellation;\n\n    if (error instanceof FlowResetError) {\n      cancellation = error;\n    } else {\n      cancellation = new DiscardedTaskError(error);\n    }\n\n    if (this.interrupts_ && this.interrupts_.length) {\n      this.interrupts_.forEach((t) => t.reject(cancellation));\n      this.interrupts_ = [];\n    }\n\n    if (this.tasks_ && this.tasks_.length) {\n      this.tasks_.forEach((t) => t.reject(cancellation));\n      this.tasks_ = [];\n    }\n\n    // Now that all of the remaining tasks have been silently cancelled (e.g. no\n    // existing callbacks on those tasks will fire), clear the silence bit on\n    // the cancellation error. This ensures additional callbacks registered in\n    // the future will actually execute.\n    cancellation.silent_ = false;\n\n    if (this.pending_) {\n      vlog(2, () => this + '.abort(); cancelling pending task', this);\n      this.pending_.task.promise.cancel(\n          /** @type {!CancellationError} */(error));\n\n    } else {\n      vlog(2, () => this + '.abort(); emitting error event', this);\n      this.emit('error', error, this);\n    }\n  }\n\n  /** @private */\n  executeNext_() {\n    if (this.state_ === TaskQueueState.FINISHED) {\n      return;\n    }\n    this.state_ = TaskQueueState.STARTED;\n\n    if (this.pending_ !== null || this.processUnhandledRejections_()) {\n      return;\n    }\n\n    var task;\n    do {\n      task = this.getNextTask_();\n    } while (task && !isPending(task.promise));\n\n    if (!task) {\n      this.state_ = TaskQueueState.FINISHED;\n      this.tasks_ = [];\n      this.interrupts_ = null;\n      vlog(2, () => this + '.emit(end)', this);\n      this.emit('end', this);\n      return;\n    }\n\n    let result = undefined;\n    this.subQ_ = new TaskQueue(this.flow_);\n\n    this.subQ_.once('end', () => {  // On task completion.\n      this.subQ_ = null;\n      this.pending_ && this.pending_.task.resolve(result);\n    });\n\n    this.subQ_.once('error', e => {  // On task failure.\n      this.subQ_ = null;\n      if (Thenable.isImplementation(result)) {\n        result.cancel(CancellationError.wrap(e));\n      }\n      this.pending_ && this.pending_.task.reject(e);\n    });\n    vlog(2, () => `${this} created ${this.subQ_} for ${task}`);\n\n    try {\n      this.pending_ = {task: task, q: this.subQ_};\n      task.promise.queue_ = this;\n      result = this.subQ_.execute_(task.execute);\n      this.subQ_.start();\n    } catch (ex) {\n      this.subQ_.abort_(ex);\n    }\n  }\n\n  /**\n   * @param {!Function} fn .\n   * @return {T} .\n   * @template T\n   * @private\n   */\n  execute_(fn) {\n    try {\n      activeFlows.push(this.flow_);\n      this.flow_.activeQueue_ = this;\n      return fn();\n    } finally {\n      this.flow_.activeQueue_ = null;\n      activeFlows.pop();\n    }\n  }\n\n  /**\n   * Process any unhandled rejections registered with this task queue. If there\n   * is a rejection, this queue will be aborted with the rejection error. If\n   * there are multiple rejections registered, this queue will be aborted with\n   * a {@link MultipleUnhandledRejectionError}.\n   * @return {boolean} whether there was an unhandled rejection.\n   * @private\n   */\n  processUnhandledRejections_() {\n    if (!this.unhandledRejections_.size) {\n      return false;\n    }\n\n    var errors = new Set();\n    for (var rejection of this.unhandledRejections_) {\n      errors.add(rejection.value_);\n    }\n    this.unhandledRejections_.clear();\n\n    var errorToReport = errors.size === 1\n        ? errors.values().next().value\n        : new MultipleUnhandledRejectionError(errors);\n\n    vlog(1, () => this + ' aborting due to unhandled rejections', this);\n    if (this.flow_.propagateUnhandledRejections_) {\n      this.abort_(errorToReport);\n      return true;\n    } else {\n      vlog(1, 'error propagation disabled; reporting to control flow');\n      this.flow_.reportUncaughtException_(errorToReport);\n      return false;\n    }\n  }\n\n  /**\n   * @param {!Task} task The task to drop.\n   * @private\n   */\n  dropTask_(task) {\n    var index;\n    if (this.interrupts_) {\n      index = this.interrupts_.indexOf(task);\n      if (index != -1) {\n        task.queue = null;\n        this.interrupts_.splice(index, 1);\n        return;\n      }\n    }\n\n    index = this.tasks_.indexOf(task);\n    if (index != -1) {\n      task.queue = null;\n      this.tasks_.splice(index, 1);\n    }\n  }\n\n  /**\n   * @param {!Task} task The task that was cancelled.\n   * @param {!CancellationError} reason The cancellation reason.\n   * @private\n   */\n  onTaskCancelled_(task, reason) {\n    if (this.pending_ && this.pending_.task === task) {\n      this.pending_.q.abort_(reason);\n    } else {\n      this.dropTask_(task);\n    }\n  }\n\n  /**\n   * @return {(Task|undefined)} the next task scheduled within this queue,\n   *     if any.\n   * @private\n   */\n  getNextTask_() {\n    var task = undefined;\n    while (true) {\n      if (this.interrupts_) {\n        task = this.interrupts_.shift();\n      }\n      if (!task && this.tasks_) {\n        task = this.tasks_.shift();\n      }\n      if (task && task.blocked) {\n        vlog(2, () => this + ' skipping blocked task ' + task, this);\n        task.queue = null;\n        task = null;\n        // TODO: recurse when tail-call optimization is available in node.\n      } else {\n        break;\n      }\n    }\n    return task;\n  }\n}\n\n\n\n/**\n * The default flow to use if no others are active.\n * @type {ControlFlow}\n */\nvar defaultFlow;\n\n\n/**\n * A stack of active control flows, with the top of the stack used to schedule\n * commands. When there are multiple flows on the stack, the flow at index N\n * represents a callback triggered within a task owned by the flow at index\n * N-1.\n * @type {!Array<!ControlFlow>}\n */\nvar activeFlows = [];\n\n\n/**\n * Changes the default flow to use when no others are active.\n * @param {!ControlFlow} flow The new default flow.\n * @throws {Error} If the default flow is not currently active.\n */\nfunction setDefaultFlow(flow) {\n  if (!usePromiseManager()) {\n    throw Error(\n        'You  may not change set the control flow when the promise'\n            +' manager is disabled');\n  }\n  if (activeFlows.length) {\n    throw Error('You may only change the default flow while it is active');\n  }\n  defaultFlow = flow;\n}\n\n\n/**\n * @return {!ControlFlow} The currently active control flow.\n * @suppress {checkTypes}\n */\nfunction controlFlow() {\n  if (!usePromiseManager()) {\n    return SIMPLE_SCHEDULER;\n  }\n\n  if (activeFlows.length) {\n    return activeFlows[activeFlows.length - 1];\n  }\n\n  if (!defaultFlow) {\n    defaultFlow = new ControlFlow;\n  }\n  return defaultFlow;\n}\n\n\n/**\n * Creates a new control flow. The provided callback will be invoked as the\n * first task within the new flow, with the flow as its sole argument. Returns\n * a promise that resolves to the callback result.\n * @param {function(!ControlFlow)} callback The entry point\n *     to the newly created flow.\n * @return {!Thenable} A promise that resolves to the callback result.\n */\nfunction createFlow(callback) {\n  var flow = new ControlFlow;\n  return flow.execute(function() {\n    return callback(flow);\n  });\n}\n\n\n/**\n * Tests is a function is a generator.\n * @param {!Function} fn The function to test.\n * @return {boolean} Whether the function is a generator.\n */\nfunction isGenerator(fn) {\n  return fn.constructor.name === 'GeneratorFunction';\n}\n\n\n/**\n * Consumes a {@code GeneratorFunction}. Each time the generator yields a\n * promise, this function will wait for it to be fulfilled before feeding the\n * fulfilled value back into {@code next}. Likewise, if a yielded promise is\n * rejected, the rejection error will be passed to {@code throw}.\n *\n * __Example 1:__ the Fibonacci Sequence.\n *\n *     promise.consume(function* fibonacci() {\n *       var n1 = 1, n2 = 1;\n *       for (var i = 0; i < 4; ++i) {\n *         var tmp = yield n1 + n2;\n *         n1 = n2;\n *         n2 = tmp;\n *       }\n *       return n1 + n2;\n *     }).then(function(result) {\n *       console.log(result);  // 13\n *     });\n *\n * __Example 2:__ a generator that throws.\n *\n *     promise.consume(function* () {\n *       yield promise.delayed(250).then(function() {\n *         throw Error('boom');\n *       });\n *     }).catch(function(e) {\n *       console.log(e.toString());  // Error: boom\n *     });\n *\n * @param {!Function} generatorFn The generator function to execute.\n * @param {Object=} opt_self The object to use as \"this\" when invoking the\n *     initial generator.\n * @param {...*} var_args Any arguments to pass to the initial generator.\n * @return {!Thenable<?>} A promise that will resolve to the\n *     generator's final result.\n * @throws {TypeError} If the given function is not a generator.\n */\nfunction consume(generatorFn, opt_self, ...var_args) {\n  if (!isGenerator(generatorFn)) {\n    throw new TypeError('Input is not a GeneratorFunction: ' +\n        generatorFn.constructor.name);\n  }\n\n  let ret;\n  return ret = createPromise((resolve, reject) => {\n    let generator = generatorFn.apply(opt_self, var_args);\n    callNext();\n\n    /** @param {*=} opt_value . */\n    function callNext(opt_value) {\n      pump(generator.next, opt_value);\n    }\n\n    /** @param {*=} opt_error . */\n    function callThrow(opt_error) {\n      pump(generator.throw, opt_error);\n    }\n\n    function pump(fn, opt_arg) {\n      if (ret instanceof ManagedPromise && !isPending(ret)) {\n        return;  // Deferred was cancelled; silently abort.\n      }\n\n      try {\n        var result = fn.call(generator, opt_arg);\n      } catch (ex) {\n        reject(ex);\n        return;\n      }\n\n      if (result.done) {\n        resolve(result.value);\n        return;\n      }\n\n      asap(result.value, callNext, callThrow);\n    }\n  });\n}\n\n\n// PUBLIC API\n\n\nmodule.exports = {\n  CancellableThenable: CancellableThenable,\n  CancellationError: CancellationError,\n  ControlFlow: ControlFlow,\n  Deferred: Deferred,\n  MultipleUnhandledRejectionError: MultipleUnhandledRejectionError,\n  Thenable: Thenable,\n  Promise: ManagedPromise,\n  Resolver: Resolver,\n  Scheduler: Scheduler,\n  all: all,\n  asap: asap,\n  captureStackTrace: captureStackTrace,\n  checkedNodeCall: checkedNodeCall,\n  consume: consume,\n  controlFlow: controlFlow,\n  createFlow: createFlow,\n  createPromise: createPromise,\n  defer: defer,\n  delayed: delayed,\n  filter: filter,\n  finally: thenFinally,\n  fulfilled: fulfilled,\n  fullyResolved: fullyResolved,\n  isGenerator: isGenerator,\n  isPromise: isPromise,\n  map: map,\n  rejected: rejected,\n  setDefaultFlow: setDefaultFlow,\n  when: when,\n\n  /**\n   * Indicates whether the promise manager is currently enabled. When disabled,\n   * attempting to use the {@link ControlFlow} or {@link ManagedPromise Promise}\n   * classes will generate an error.\n   *\n   * The promise manager is currently enabled by default, but may be disabled\n   * by setting the environment variable `SELENIUM_PROMISE_MANAGER=0` or by\n   * setting this property to false. Setting this property will always take\n   * precedence over the use of the environment variable.\n   *\n   * @return {boolean} Whether the promise manager is enabled.\n   * @see <https://github.com/SeleniumHQ/selenium/issues/2969>\n   */\n  get USE_PROMISE_MANAGER() { return usePromiseManager(); },\n  set USE_PROMISE_MANAGER(/** boolean */value) { USE_PROMISE_MANAGER = value; },\n\n  get LONG_STACK_TRACES() { return LONG_STACK_TRACES; },\n  set LONG_STACK_TRACES(v) { LONG_STACK_TRACES = v; },\n};\n"]}
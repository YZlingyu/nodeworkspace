{"version":3,"sources":["events.js"],"names":[],"mappings":"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","file":"events-compiled.js","sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n'use strict';\n\n/**\n * Describes an event listener registered on an {@linkplain EventEmitter}.\n */\nclass Listener {\n  /**\n   * @param {!Function} fn The actual listener function.\n   * @param {(Object|undefined)} scope The object in whose scope to invoke the\n   *     listener.\n   * @param {boolean} oneshot Whether this listener should only be used once.\n   */\n  constructor(fn, scope, oneshot) {\n    this.fn = fn;\n    this.scope = scope;\n    this.oneshot = oneshot;\n  }\n}\n\n\n/** @type {!WeakMap<!EventEmitter, !Map<string, !Set<!Listener>>>} */\nconst EVENTS = new WeakMap;\n\n\n/**\n * Object that can emit events for others to listen for.\n */\nclass EventEmitter {\n  /**\n   * Fires an event and calls all listeners.\n   * @param {string} type The type of event to emit.\n   * @param {...*} var_args Any arguments to pass to each listener.\n   */\n  emit(type, var_args) {\n    let events = EVENTS.get(this);\n    if (!events) {\n      return;\n    }\n\n    let args = Array.prototype.slice.call(arguments, 1);\n\n    let listeners = events.get(type);\n    if (listeners) {\n      for (let listener of listeners) {\n        listener.fn.apply(listener.scope, args);\n        if (listener.oneshot) {\n          listeners.delete(listener);\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns a mutable list of listeners for a specific type of event.\n   * @param {string} type The type of event to retrieve the listeners for.\n   * @return {!Set<!Listener>} The registered listeners for the given event\n   *     type.\n   */\n  listeners(type) {\n    let events = EVENTS.get(this);\n    if (!events) {\n      events = new Map;\n      EVENTS.set(this, events);\n    }\n\n    let listeners = events.get(type);\n    if (!listeners) {\n      listeners = new Set;\n      events.set(type, listeners);\n    }\n    return listeners;\n  }\n\n  /**\n   * Registers a listener.\n   * @param {string} type The type of event to listen for.\n   * @param {!Function} fn The function to invoke when the event is fired.\n   * @param {Object=} opt_self The object in whose scope to invoke the listener.\n   * @param {boolean=} opt_oneshot Whether the listener should b (e removed after\n   *    the first event is fired.\n   * @return {!EventEmitter} A self reference.\n   * @private\n   */\n  addListener_(type, fn, opt_self, opt_oneshot) {\n    let listeners = this.listeners(type);\n    for (let listener of listeners) {\n      if (listener.fn === fn) {\n        return this;\n      }\n    }\n    listeners.add(new Listener(fn, opt_self || undefined, !!opt_oneshot));\n    return this;\n  }\n\n  /**\n   * Registers a listener.\n   * @param {string} type The type of event to listen for.\n   * @param {!Function} fn The function to invoke when the event is fired.\n   * @param {Object=} opt_self The object in whose scope to invoke the listener.\n   * @return {!EventEmitter} A self reference.\n   */\n  addListener(type, fn, opt_self) {\n    return this.addListener_(type, fn, opt_self, false);\n  }\n\n  /**\n   * Registers a one-time listener which will be called only the first time an\n   * event is emitted, after which it will be removed.\n   * @param {string} type The type of event to listen for.\n   * @param {!Function} fn The function to invoke when the event is fired.\n   * @param {Object=} opt_self The object in whose scope to invoke the listener.\n   * @return {!EventEmitter} A self reference.\n   */\n  once(type, fn, opt_self) {\n    return this.addListener_(type, fn, opt_self, true);\n  }\n\n  /**\n   * An alias for {@link #addListener() addListener()}.\n   * @param {string} type The type of event to listen for.\n   * @param {!Function} fn The function to invoke when the event is fired.\n   * @param {Object=} opt_self The object in whose scope to invoke the listener.\n   * @return {!EventEmitter} A self reference.\n   */\n  on(type, fn, opt_self) {\n    return this.addListener(type, fn, opt_self);\n  }\n\n  /**\n   * Removes a previously registered event listener.\n   * @param {string} type The type of event to unregister.\n   * @param {!Function} listenerFn The handler function to remove.\n   * @return {!EventEmitter} A self reference.\n   */\n  removeListener(type, listenerFn) {\n    if (typeof type !== 'string' || typeof listenerFn !== 'function') {\n      throw TypeError('invalid args: expected (string, function), got ('\n          + (typeof type) + ', ' + (typeof listenerFn) + ')');\n    }\n\n    let events = EVENTS.get(this);\n    if (!events) {\n      return this;\n    }\n\n    let listeners = events.get(type);\n    if (!listeners) {\n      return this;\n    }\n\n    let match;\n    for (let listener of listeners) {\n      if (listener.fn === listenerFn) {\n        match = listener;\n        break;\n      }\n    }\n    if (match) {\n      listeners.delete(match);\n      if (!listeners.size) {\n        events.delete(type);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Removes all listeners for a specific type of event. If no event is\n   * specified, all listeners across all types will be removed.\n   * @param {string=} opt_type The type of event to remove listeners from.\n   * @return {!EventEmitter} A self reference.\n   */\n  removeAllListeners(opt_type) {\n    let events = EVENTS.get(this);\n    if (events) {\n      if (typeof opt_type === 'string') {\n        events.delete(opt_type);\n      } else {\n        EVENTS.delete(this);\n      }\n    }\n    return this;\n  }\n}\n\n\n// PUBLIC API\n\n\nmodule.exports = {\n  EventEmitter: EventEmitter,\n  Listener: Listener\n};\n"]}
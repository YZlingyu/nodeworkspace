{"version":3,"sources":["timeout.js"],"names":[],"mappings":"AAAA;;AAEA,OAAO,cAAP,CAAsB,OAAtB,EAA+B,YAA/B,EAA6C;AACzC,WAAO;AADkC,CAA7C;AAGA,QAAQ,OAAR,GAAkB,OAAlB;;AAEA,IAAI,iBAAiB,QAAQ,0BAAR,CAArB;;AAEA,IAAI,kBAAkB,uBAAuB,cAAvB,CAAtB;;AAEA,SAAS,sBAAT,CAAgC,GAAhC,EAAqC;AAAE,WAAO,OAAO,IAAI,UAAX,GAAwB,GAAxB,GAA8B,EAAE,SAAS,GAAX,EAArC;AAAwD;;AAE/F;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0CA,SAAS,OAAT,CAAiB,OAAjB,EAA0B,YAA1B,EAAwC,IAAxC,EAA8C;AAC1C,QAAI,gBAAJ,EAAsB,KAAtB;AACA,QAAI,WAAW,KAAf;;AAEA,aAAS,gBAAT,GAA4B;AACxB,YAAI,CAAC,QAAL,EAAe;AACX,6BAAiB,KAAjB,CAAuB,IAAvB,EAA6B,SAA7B;AACA,yBAAa,KAAb;AACH;AACJ;;AAED,aAAS,eAAT,GAA2B;AACvB,YAAI,OAAO,QAAQ,IAAR,IAAgB,WAA3B;AACA,YAAI,QAAQ,IAAI,KAAJ,CAAU,wBAAwB,IAAxB,GAA+B,cAAzC,CAAZ;AACA,cAAM,IAAN,GAAa,WAAb;AACA,YAAI,IAAJ,EAAU;AACN,kBAAM,IAAN,GAAa,IAAb;AACH;AACD,mBAAW,IAAX;AACA,yBAAiB,KAAjB;AACH;;AAED,WAAO,CAAC,GAAG,gBAAgB,OAApB,EAA6B,UAAU,IAAV,EAAgB,YAAhB,EAA8B;AAC9D,2BAAmB,YAAnB;AACA;AACA,gBAAQ,WAAW,eAAX,EAA4B,YAA5B,CAAR;AACA,gBAAQ,KAAR,CAAc,IAAd,EAAoB,KAAK,MAAL,CAAY,gBAAZ,CAApB;AACH,KALM,CAAP;AAMH;AACD,OAAO,OAAP,GAAiB,QAAQ,SAAR,CAAjB","file":"timeout-compiled.js","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = timeout;\n\nvar _initialParams = require('./internal/initialParams');\n\nvar _initialParams2 = _interopRequireDefault(_initialParams);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Sets a time limit on an asynchronous function. If the function does not call\n * its callback within the specified milliseconds, it will be called with a\n * timeout error. The code property for the error object will be `'ETIMEDOUT'`.\n *\n * @name timeout\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {Function} asyncFn - The asynchronous function you want to set the\n * time limit.\n * @param {number} milliseconds - The specified time limit.\n * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)\n * to timeout Error for more information..\n * @returns {Function} Returns a wrapped function that can be used with any of\n * the control flow functions. Invoke this function with the same\n * parameters as you would `asyncFunc`.\n * @example\n *\n * function myFunction(foo, callback) {\n *     doAsyncTask(foo, function(err, data) {\n *         // handle errors\n *         if (err) return callback(err);\n *\n *         // do some stuff ...\n *\n *         // return processed data\n *         return callback(null, data);\n *     });\n * }\n *\n * var wrapped = async.timeout(myFunction, 1000);\n *\n * // call `wrapped` as you would `myFunction`\n * wrapped({ bar: 'bar' }, function(err, data) {\n *     // if `myFunction` takes < 1000 ms to execute, `err`\n *     // and `data` will have their expected values\n *\n *     // else `err` will be an Error with the code 'ETIMEDOUT'\n * });\n */\nfunction timeout(asyncFn, milliseconds, info) {\n    var originalCallback, timer;\n    var timedOut = false;\n\n    function injectedCallback() {\n        if (!timedOut) {\n            originalCallback.apply(null, arguments);\n            clearTimeout(timer);\n        }\n    }\n\n    function timeoutCallback() {\n        var name = asyncFn.name || 'anonymous';\n        var error = new Error('Callback function \"' + name + '\" timed out.');\n        error.code = 'ETIMEDOUT';\n        if (info) {\n            error.info = info;\n        }\n        timedOut = true;\n        originalCallback(error);\n    }\n\n    return (0, _initialParams2.default)(function (args, origCallback) {\n        originalCallback = origCallback;\n        // setup timer and call original function\n        timer = setTimeout(timeoutCallback, milliseconds);\n        asyncFn.apply(null, args.concat(injectedCallback));\n    });\n}\nmodule.exports = exports['default'];"]}
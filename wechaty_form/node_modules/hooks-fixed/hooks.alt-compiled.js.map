{"version":3,"sources":["hooks.alt.js"],"names":[],"mappings":"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","file":"hooks.alt-compiled.js","sourcesContent":["/**\n * Hooks are useful if we want to add a method that automatically has `pre` and `post` hooks.\n * For example, it would be convenient to have `pre` and `post` hooks for `save`.\n * _.extend(Model, mixins.hooks);\n * Model.hook('save', function () {\n *  console.log('saving');\n * });\n * Model.pre('save', function (next, done) {\n *  console.log('about to save');\n *  next();\n * });\n * Model.post('save', function (next, done) {\n *  console.log('saved');\n *  next();\n * });\n *\n * var m = new Model();\n * m.save();\n * // about to save\n * // saving\n * // saved \n */\n\n// TODO Add in pre and post skipping options\nmodule.exports = {\n  /**\n   *  Declares a new hook to which you can add pres and posts\n   *  @param {String} name of the function\n   *  @param {Function} the method\n   *  @param {Function} the error handler callback\n   */\n  hook: function (name, fn, err) {\n    if (arguments.length === 1 && typeof name === 'object') {\n      for (var k in name) { // `name` is a hash of hookName->hookFn\n        this.hook(k, name[k]);\n      }\n      return;\n    }\n\n    if (!err) err = fn;\n\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {}\n      , posts = proto._posts = proto._posts || {};\n    pres[name] = pres[name] || [];\n    posts[name] = posts[name] || [];\n\n    function noop () {}\n\n    proto[name] = function () {\n      var self = this\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , numAsyncPres = 0\n        , hookArgs = [].slice.call(arguments)\n        , preChain = pres.map( function (pre, i) {\n            var wrapper = function () {\n              if (arguments[0] instanceof Error)\n                return err(arguments[0]);\n              if (numAsyncPres) {\n                // arguments[1] === asyncComplete\n                if (arguments.length)\n                  hookArgs = [].slice.call(arguments, 2);\n                pre.apply(self, \n                  [ preChain[i+1] || allPresInvoked, \n                    asyncComplete\n                  ].concat(hookArgs)\n                );\n              } else {\n                if (arguments.length)\n                  hookArgs = [].slice.call(arguments);\n                pre.apply(self,\n                  [ preChain[i+1] || allPresDone ].concat(hookArgs));\n              }\n            }; // end wrapper = function () {...\n            if (wrapper.isAsync = pre.isAsync)\n              numAsyncPres++;\n            return wrapper;\n          }); // end posts.map(...)\n      function allPresInvoked () {\n        if (arguments[0] instanceof Error)\n          err(arguments[0]);\n      }\n\n      function allPresDone () {\n        if (arguments[0] instanceof Error)\n          return err(arguments[0]);\n        if (arguments.length)\n          hookArgs = [].slice.call(arguments);\n        fn.apply(self, hookArgs);\n        var postChain = posts.map( function (post, i) {\n          var wrapper = function () {\n            if (arguments[0] instanceof Error)\n              return err(arguments[0]);\n            if (arguments.length)\n              hookArgs = [].slice.call(arguments);\n            post.apply(self,\n              [ postChain[i+1] || noop].concat(hookArgs));\n          }; // end wrapper = function () {...\n          return wrapper;\n        }); // end posts.map(...)\n        if (postChain.length) postChain[0]();\n      }\n\n      if (numAsyncPres) {\n        complete = numAsyncPres;\n        function asyncComplete () {\n          if (arguments[0] instanceof Error)\n            return err(arguments[0]);\n          --complete || allPresDone.call(this);\n        }\n      }\n      (preChain[0] || allPresDone)();\n    };\n\n    return this;\n  },\n\n  pre: function (name, fn, isAsync) {\n    var proto = this.prototype\n      , pres = proto._pres = proto._pres || {};\n    if (fn.isAsync = isAsync) {\n      this.prototype[name].numAsyncPres++;\n    }\n    (pres[name] = pres[name] || []).push(fn);\n    return this;\n  },\n  post: function (name, fn, isAsync) {\n    var proto = this.prototype\n      , posts = proto._posts = proto._posts || {};\n    (posts[name] = posts[name] || []).push(fn);\n    return this;\n  }\n};\n"]}
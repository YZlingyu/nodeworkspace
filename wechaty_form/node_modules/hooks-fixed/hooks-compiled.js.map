{"version":3,"sources":["hooks.js"],"names":[],"mappings":"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","file":"hooks-compiled.js","sourcesContent":["// TODO Add in pre and post skipping options\nmodule.exports = {\n  /**\n   *  Declares a new hook to which you can add pres and posts\n   *  @param {String} name of the function\n   *  @param {Function} the method\n   *  @param {Function} the error handler callback\n   */\n  $hook: function (name, fn, errorCb) {\n    if (arguments.length === 1 && typeof name === 'object') {\n      for (var k in name) { // `name` is a hash of hookName->hookFn\n        this.$hook(k, name[k]);\n      }\n      return;\n    }\n\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {}\n      , posts = proto._posts = proto._posts || {};\n    pres[name] = pres[name] || [];\n    posts[name] = posts[name] || [];\n\n    proto[name] = function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if ('function' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === 'function'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error(\"Your pre must have next and done arguments -- e.g., function (next, done, ...)\");\n              if (currPre.length < 1)\n                throw new Error(\"Your pre must have a next argument -- e.g., function (next, ...)\");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error(\"Your post must have a next argument -- e.g., function (next, ...)\");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === 'function'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === 'function'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== 'function') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    };\n    \n    proto[name].numAsyncPres = 0;\n\n    return this;\n  },\n\n  pre: function (name, isAsync, fn, errorCb) {\n    if ('boolean' !== typeof arguments[1]) {\n      errorCb = fn;\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {};\n\n    this._lazySetupHooks(proto, name, errorCb);\n\n    if (fn.isAsync = isAsync) {\n      proto[name].numAsyncPres++;\n    }\n\n    (pres[name] = pres[name] || []).push(fn);\n    return this;\n  },\n  post: function (name, isAsync, fn) {\n    if (arguments.length === 2) {\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , posts = proto._posts = proto._posts || {};\n    \n    this._lazySetupHooks(proto, name);\n    (posts[name] = posts[name] || []).push(fn);\n    return this;\n  },\n  removePre: function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , pres = proto._pres || (proto._pres || {});\n    if (!pres[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all pre callbacks for hook `name`\n      pres[name].length = 0;\n    } else {\n      pres[name] = pres[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  },\n  removePost: function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , posts = proto._posts || (proto._posts || {});\n    if (!posts[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all post callbacks for hook `name`\n      posts[name].length = 0;\n    } else {\n      posts[name] = posts[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  },\n  \n  _lazySetupHooks: function (proto, methodName, errorCb) {\n    if ('undefined' === typeof proto[methodName].numAsyncPres) {\n      this.$hook(methodName, proto[methodName], errorCb);\n    }\n  }\n};\n\nfunction once (fn, scope) {\n  return function fnWrapper () {\n    if (fnWrapper.hookCalled) return;\n    fnWrapper.hookCalled = true;\n    fn.apply(scope, arguments);\n  };\n}\n"]}
{"version":3,"sources":["spec.asynct.js"],"names":[],"mappings":"AAAA;;;;;;;;AAQA,IAAI,KAAK,QAAQ,IAAR,CAAT;AACA,IAAI,KAAK,QAAQ,OAAR,EAAiB,KAAjB,CAAuB,QAAvB,CAAT;AACA,IAAI,OAAO,QAAQ,aAAR,CAAX;;AAEA,QAAQ,eAAR,IAA2B,UAAU,IAAV,EAAgB;;AAEzC,MAAI,SAAS,GAAG,OAAH,EAAb;AACA,MAAI,IAAI,KAAK,MAAL,EAAa,KAAb,GAAqB,QAArB,EAAR;;AAEA,SAAO,KAAP,CAAa,CAAb;AACA,SAAO,KAAP,CAAa,CAAb;AACA,SAAO,KAAP;AACA,SAAO,KAAP,CAAa,CAAb;AACA,SAAO,MAAP;AACA,SAAO,KAAP,CAAa,CAAb;AACA,SAAO,GAAP,CAAW,CAAX,EAXyC,CAW3B;;AAEd,UAAQ,QAAR,CAAiB,YAAW;AAC1B,MAAE,QAAF;AACA,SAAK,IAAL;AACD,GAHD;AAID,CAjBD;;AAmBA,QAAQ,+BAAR,IAA2C,UAAU,IAAV,EAAgB;;AAEzD,MAAI,SAAS,GAAG,OAAH,EAAb;AACA,MAAI,IAAI,KAAK,MAAL,EAAa,KAAb,GAAqB,QAArB,EAAR;;AAEA,SAAO,KAAP,CAAa,CAAb;AACA,SAAO,KAAP,CAAa,CAAb;AACA,SAAO,GAAP,CAAW,CAAX,EAPyD,CAO3C;AACd,SAAO,KAAP,CAAa,CAAb,EARyD,CAQzC;;AAEhB,UAAQ,QAAR,CAAiB,YAAY;AAC3B,MAAE,QAAF;AACA,SAAK,IAAL;AACD,GAHD;AAKD,CAfD;;AAiBA,QAAQ,UAAR,IAAsB,UAAU,IAAV,EAAgB;;AAEpC,MAAI,SAAS,GAAG,OAAH,EAAb;AACA,MAAI,IAAI,KAAK,MAAL,EAAa,KAAb,GAAqB,QAArB,EAAR;;AAEA,SAAO,GAAP,GALoC,CAKvB;;AAEb,UAAQ,QAAR,CAAiB,YAAY;AAC3B,MAAE,QAAF;AACA,SAAK,IAAL;AACD,GAHD;AAKD,CAZD;;AAeA;;;;;;;;;;;;;;;;;;;;;AAsBA,QAAQ,UAAR,EAAoB,MAApB","file":"spec.asynct-compiled.js","sourcesContent":["/*\n  assert that data is called many times\n  assert that end is called eventually\n\n  assert that when stream enters pause state,\n  on drain is emitted eventually.\n*/\n\nvar es = require('..')\nvar it = require('it-is').style('colour')\nvar spec = require('stream-spec')\n\nexports['simple stream'] = function (test) {\n\n  var stream = es.through()\n  var x = spec(stream).basic().pausable()\n\n  stream.write(1)\n  stream.write(1)\n  stream.pause()\n  stream.write(1)\n  stream.resume()\n  stream.write(1)\n  stream.end(2) //this will call write()\n\n  process.nextTick(function (){\n    x.validate()\n    test.done()\n  }) \n}\n\nexports['throw on write when !writable'] = function (test) {\n\n  var stream = es.through()\n  var x = spec(stream).basic().pausable()\n\n  stream.write(1)\n  stream.write(1)\n  stream.end(2) //this will call write()\n  stream.write(1) //this will be throwing..., but the spec will catch it.\n\n  process.nextTick(function () {\n    x.validate()\n    test.done()\n  })\n  \n}\n\nexports['end fast'] = function (test) {\n\n  var stream = es.through()\n  var x = spec(stream).basic().pausable()\n\n  stream.end() //this will call write()\n\n  process.nextTick(function () {\n    x.validate()\n    test.done()\n  })\n  \n}\n\n\n/*\n  okay, that was easy enough, whats next?\n\n  say, after you call paused(), write should return false\n  until resume is called.\n\n  simple way to implement this:\n    write must return !paused\n  after pause() paused = true\n  after resume() paused = false\n\n  on resume, if !paused drain is emitted again.\n  after drain, !paused\n\n  there are lots of subtle ordering bugs in streams.\n\n  example, set !paused before emitting drain.\n\n  the stream api is stateful. \n*/\n\n\nrequire('./helper')(module)\n"]}
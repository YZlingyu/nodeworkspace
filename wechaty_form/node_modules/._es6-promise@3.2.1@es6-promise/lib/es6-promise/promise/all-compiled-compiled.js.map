{"version":3,"sources":["all-compiled.js"],"names":[],"mappings":"AAAA,OAAO,UAAP,MAAuB,eAAvB;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+CA,eAAe,SAAS,GAAT,CAAa,OAAb,EAAsB;AACnC,SAAO,IAAI,UAAJ,CAAe,IAAf,EAAqB,OAArB,EAA8B,OAArC;AACD;;AAED","file":"all-compiled-compiled.js","sourcesContent":["import Enumerator from '../enumerator';\n\n/**\n  `Promise.all` accepts an array of promises, and returns a new promise which\n  is fulfilled with an array of fulfillment values for the passed promises, or\n  rejected with the reason of the first passed promise to be rejected. It casts all\n  elements of the passed iterable to promises as it runs this algorithm.\n\n  Example:\n\n  ```javascript\n  var promise1 = resolve(1);\n  var promise2 = resolve(2);\n  var promise3 = resolve(3);\n  var promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // The array here would be [ 1, 2, 3 ];\n  });\n  ```\n\n  If any of the `promises` given to `all` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promises's\n  rejection handler. For example:\n\n  Example:\n\n  ```javascript\n  var promise1 = resolve(1);\n  var promise2 = reject(new Error(\"2\"));\n  var promise3 = reject(new Error(\"3\"));\n  var promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(error) {\n    // error.message === \"2\"\n  });\n  ```\n\n  @method all\n  @static\n  @param {Array} entries array of promises\n  @param {String} label optional string for labeling the promise.\n  Useful for tooling.\n  @return {Promise} promise that is fulfilled when all `promises` have been\n  fulfilled, or rejected if any of them become rejected.\n  @static\n*/\nexport default function all(entries) {\n  return new Enumerator(this, entries).promise;\n}\n\n//# sourceMappingURL=all-compiled.js.map"]}
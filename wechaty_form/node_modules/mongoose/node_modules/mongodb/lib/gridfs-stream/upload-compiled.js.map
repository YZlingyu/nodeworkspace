{"version":3,"sources":["upload.js"],"names":[],"mappings":"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","file":"upload-compiled.js","sourcesContent":["var core = require('mongodb-core');\nvar crypto = require('crypto');\nvar stream = require('stream');\nvar util = require('util');\n\nvar ERROR_NAMESPACE_NOT_FOUND = 26;\n\nmodule.exports = GridFSBucketWriteStream;\n\n/**\n * A writable stream that enables you to write buffers to GridFS.\n *\n * Do not instantiate this class directly. Use `openUploadStream()` instead.\n *\n * @class\n * @param {GridFSBucket} bucket Handle for this stream's corresponding bucket\n * @param {string} filename The value of the 'filename' key in the files doc\n * @param {object} [options=null] Optional settings.\n * @param {string|number|object} [options.id=null] Custom file id for the GridFS file.\n * @param {number} [options.chunkSizeBytes=null] The chunk size to use, in bytes\n * @param {number} [options.w=null] The write concern\n * @param {number} [options.wtimeout=null] The write concern timeout\n * @param {number} [options.j=null] The journal write concern\n * @fires GridFSBucketWriteStream#error\n * @fires GridFSBucketWriteStream#finish\n * @return {GridFSBucketWriteStream} a GridFSBucketWriteStream instance.\n */\n\nfunction GridFSBucketWriteStream(bucket, filename, options) {\n  options = options || {};\n  this.bucket = bucket;\n  this.chunks = bucket.s._chunksCollection;\n  this.filename = filename;\n  this.files = bucket.s._filesCollection;\n  this.options = options;\n\n  this.id = options.id ? options.id : core.BSON.ObjectId();\n  this.chunkSizeBytes = this.options.chunkSizeBytes;\n  this.bufToStore = new Buffer(this.chunkSizeBytes);\n  this.length = 0;\n  this.md5 = crypto.createHash('md5');\n  this.n = 0;\n  this.pos = 0;\n  this.state = {\n    streamEnd: false,\n    outstandingRequests: 0,\n    errored: false,\n    aborted: false,\n    promiseLibrary: this.bucket.s.promiseLibrary\n  };\n\n  if (!this.bucket.s.calledOpenUploadStream) {\n    this.bucket.s.calledOpenUploadStream = true;\n\n    var _this = this;\n    checkIndexes(this, function() {\n      _this.bucket.s.checkedIndexes = true;\n      _this.bucket.emit('index');\n    });\n  }\n}\n\nutil.inherits(GridFSBucketWriteStream, stream.Writable);\n\n/**\n * An error occurred\n *\n * @event GridFSBucketWriteStream#error\n * @type {Error}\n */\n\n/**\n * `end()` was called and the write stream successfully wrote the file\n * metadata and all the chunks to MongoDB.\n *\n * @event GridFSBucketWriteStream#finish\n * @type {object}\n */\n\n/**\n * Write a buffer to the stream.\n *\n * @method\n * @param {Buffer} chunk Buffer to write\n * @param {String} encoding Optional encoding for the buffer\n * @param {Function} callback Function to call when the chunk was added to the buffer, or if the entire chunk was persisted to MongoDB if this chunk caused a flush.\n * @return {Boolean} False if this write required flushing a chunk to MongoDB. True otherwise.\n */\n\nGridFSBucketWriteStream.prototype.write = function(chunk, encoding, callback) {\n  var _this = this;\n  return waitForIndexes(this, function() {\n    return doWrite(_this, chunk, encoding, callback);\n  });\n};\n\n/**\n * Places this write stream into an aborted state (all future writes fail)\n * and deletes all chunks that have already been written.\n *\n * @method\n * @param {GridFSBucket~errorCallback} callback called when chunks are successfully removed or error occurred\n * @return {Promise} if no callback specified\n */\n\nGridFSBucketWriteStream.prototype.abort = function(callback) {\n  if (this.state.streamEnd) {\n    var error = new Error('Cannot abort a stream that has already completed');\n    if (typeof callback == 'function') {\n      return callback(error);\n    }\n    return this.state.promiseLibrary.reject(error);\n  }\n  if (this.state.aborted) {\n    error = new Error('Cannot call abort() on a stream twice');\n    if (typeof callback == 'function') {\n      return callback(error);\n    }\n    return this.state.promiseLibrary.reject(error);\n  }\n  this.state.aborted = true;\n  this.chunks.deleteMany({ files_id: this.id }, function(error) {\n    if(typeof callback == 'function') callback(error);\n  });\n};\n\n/**\n * Tells the stream that no more data will be coming in. The stream will\n * persist the remaining data to MongoDB, write the files document, and\n * then emit a 'finish' event.\n *\n * @method\n * @param {Buffer} chunk Buffer to write\n * @param {String} encoding Optional encoding for the buffer\n * @param {Function} callback Function to call when all files and chunks have been persisted to MongoDB\n */\n\nGridFSBucketWriteStream.prototype.end = function(chunk, encoding, callback) {\n  var _this = this;\n  if(typeof chunk == 'function') {\n    callback = chunk, chunk = null, encoding = null;\n  } else if(typeof encoding == 'function') {\n    callback = encoding, encoding = null;\n  }\n\n  if (checkAborted(this, callback)) {\n    return;\n  }\n  this.state.streamEnd = true;\n\n  if (callback) {\n    this.once('finish', function(result) {\n      callback(null, result);\n    });\n  }\n\n  if (!chunk) {\n    waitForIndexes(this, function() {\n      writeRemnant(_this);\n    });\n    return;\n  }\n\n  this.write(chunk, encoding, function() {\n    writeRemnant(_this);\n  });\n};\n\n/**\n * @ignore\n */\n\nfunction __handleError(_this, error, callback) {\n  if (_this.state.errored) {\n    return;\n  }\n  _this.state.errored = true;\n  if (callback) {\n    return callback(error);\n  }\n  _this.emit('error', error);\n}\n\n/**\n * @ignore\n */\n\nfunction createChunkDoc(filesId, n, data) {\n  return {\n    _id: core.BSON.ObjectId(),\n    files_id: filesId,\n    n: n,\n    data: data\n  };\n}\n\n/**\n * @ignore\n */\n\nfunction checkChunksIndex(_this, callback) {\n  _this.chunks.listIndexes().toArray(function(error, indexes) {\n    if (error) {\n      // Collection doesn't exist so create index\n      if (error.code === ERROR_NAMESPACE_NOT_FOUND) {\n        var index = { files_id: 1, n: 1 };\n        _this.chunks.createIndex(index, { background: false, unique: true }, function(error) {\n          if (error) {\n            return callback(error);\n          }\n\n          callback();\n        });\n        return;\n      }\n      return callback(error);\n    }\n\n    var hasChunksIndex = false;\n    indexes.forEach(function(index) {\n      if (index.key) {\n        var keys = Object.keys(index.key);\n        if (keys.length === 2 && index.key.files_id === 1 &&\n            index.key.n === 1) {\n          hasChunksIndex = true;\n        }\n      }\n    });\n\n    if (hasChunksIndex) {\n      callback();\n    } else {\n      index = { files_id: 1, n: 1 };\n      var indexOptions = getWriteOptions(_this);\n\n      indexOptions.background = false;\n      indexOptions.unique = true;\n\n      _this.chunks.createIndex(index, indexOptions, function(error) {\n        if (error) {\n          return callback(error);\n        }\n\n        callback();\n      });\n    }\n  });\n}\n\n/**\n * @ignore\n */\n\nfunction checkDone(_this, callback) {\n  if (_this.state.streamEnd &&\n      _this.state.outstandingRequests === 0 &&\n      !_this.state.errored) {\n    var filesDoc = createFilesDoc(_this.id, _this.length, _this.chunkSizeBytes,\n      _this.md5.digest('hex'), _this.filename, _this.options.contentType,\n      _this.options.aliases, _this.options.metadata);\n\n    if (checkAborted(_this, callback)) {\n      return false;\n    }\n\n    _this.files.insert(filesDoc, getWriteOptions(_this), function(error) {\n      if (error) {\n        return __handleError(_this, error, callback);\n      }\n      _this.emit('finish', filesDoc);\n    });\n\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * @ignore\n */\n\nfunction checkIndexes(_this, callback) {\n  _this.files.findOne({}, { _id: 1 }, function(error, doc) {\n    if (error) {\n      return callback(error);\n    }\n    if (doc) {\n      return callback();\n    }\n\n    _this.files.listIndexes().toArray(function(error, indexes) {\n      if (error) {\n        // Collection doesn't exist so create index\n        if (error.code === ERROR_NAMESPACE_NOT_FOUND) {\n          var index = { filename: 1, uploadDate: 1 };\n          _this.files.createIndex(index, { background: false }, function(error) {\n            if (error) {\n              return callback(error);\n            }\n\n            checkChunksIndex(_this, callback);\n          });\n          return;\n        }\n        return callback(error);\n      }\n\n      var hasFileIndex = false;\n      indexes.forEach(function(index) {\n        var keys = Object.keys(index.key);\n        if (keys.length === 2 && index.key.filename === 1 &&\n            index.key.uploadDate === 1) {\n          hasFileIndex = true;\n        }\n      });\n\n      if (hasFileIndex) {\n        checkChunksIndex(_this, callback);\n      } else {\n        index = { filename: 1, uploadDate: 1 };\n\n        var indexOptions = getWriteOptions(_this);\n\n        indexOptions.background = false;\n\n        _this.files.createIndex(index, indexOptions, function(error) {\n          if (error) {\n            return callback(error);\n          }\n\n          checkChunksIndex(_this, callback);\n        });\n      }\n    });\n  });\n}\n\n/**\n * @ignore\n */\n\nfunction createFilesDoc(_id, length, chunkSize, md5, filename, contentType,\n  aliases, metadata) {\n  var ret = {\n    _id: _id,\n    length: length,\n    chunkSize: chunkSize,\n    uploadDate: new Date(),\n    md5: md5,\n    filename: filename\n  };\n\n  if (contentType) {\n    ret.contentType = contentType;\n  }\n\n  if (aliases) {\n    ret.aliases = aliases;\n  }\n\n  if (metadata) {\n    ret.metadata = metadata;\n  }\n\n  return ret;\n}\n\n/**\n * @ignore\n */\n\nfunction doWrite(_this, chunk, encoding, callback) {\n  if (checkAborted(_this, callback)) {\n    return false;\n  }\n\n  var inputBuf = (Buffer.isBuffer(chunk)) ?\n    chunk : new Buffer(chunk, encoding);\n\n  _this.length += inputBuf.length;\n\n  // Input is small enough to fit in our buffer\n  if (_this.pos + inputBuf.length < _this.chunkSizeBytes) {\n    inputBuf.copy(_this.bufToStore, _this.pos);\n    _this.pos += inputBuf.length;\n\n    callback && callback();\n\n    // Note that we reverse the typical semantics of write's return value\n    // to be compatible with node's `.pipe()` function.\n    // True means client can keep writing.\n    return true;\n  }\n\n  // Otherwise, buffer is too big for current chunk, so we need to flush\n  // to MongoDB.\n  var inputBufRemaining = inputBuf.length;\n  var spaceRemaining = _this.chunkSizeBytes - _this.pos;\n  var numToCopy = Math.min(spaceRemaining, inputBuf.length);\n  var outstandingRequests = 0;\n  while (inputBufRemaining > 0) {\n    var inputBufPos = inputBuf.length - inputBufRemaining;\n    inputBuf.copy(_this.bufToStore, _this.pos,\n      inputBufPos, inputBufPos + numToCopy);\n    _this.pos += numToCopy;\n    spaceRemaining -= numToCopy;\n    if (spaceRemaining === 0) {\n      _this.md5.update(_this.bufToStore);\n      var doc = createChunkDoc(_this.id, _this.n, _this.bufToStore);\n      ++_this.state.outstandingRequests;\n      ++outstandingRequests;\n\n      if (checkAborted(_this, callback)) {\n        return false;\n      }\n\n      _this.chunks.insert(doc, getWriteOptions(_this), function(error) {\n        if (error) {\n          return __handleError(_this, error);\n        }\n        --_this.state.outstandingRequests;\n        --outstandingRequests;\n        if (!outstandingRequests) {\n          _this.emit('drain', doc);\n          callback && callback();\n          checkDone(_this);\n        }\n      });\n\n      spaceRemaining = _this.chunkSizeBytes;\n      _this.pos = 0;\n      ++_this.n;\n    }\n    inputBufRemaining -= numToCopy;\n    numToCopy = Math.min(spaceRemaining, inputBufRemaining);\n  }\n\n  // Note that we reverse the typical semantics of write's return value\n  // to be compatible with node's `.pipe()` function.\n  // False means the client should wait for the 'drain' event.\n  return false;\n}\n\n/**\n * @ignore\n */\n\nfunction getWriteOptions(_this) {\n  var obj = {};\n  if (_this.options.writeConcern) {\n    obj.w = _this.options.writeConcern.w;\n    obj.wtimeout = _this.options.writeConcern.wtimeout;\n    obj.j = _this.options.writeConcern.j;\n  }\n  return obj;\n}\n\n/**\n * @ignore\n */\n\nfunction waitForIndexes(_this, callback) {\n  if (_this.bucket.s.checkedIndexes) {\n    return callback(false);\n  }\n\n  _this.bucket.once('index', function() {\n    callback(true);\n  });\n\n  return true;\n}\n\n/**\n * @ignore\n */\n\nfunction writeRemnant(_this, callback) {\n  // Buffer is empty, so don't bother to insert\n  if (_this.pos === 0) {\n    return checkDone(_this, callback);\n  }\n\n  ++_this.state.outstandingRequests;\n\n  // Create a new buffer to make sure the buffer isn't bigger than it needs\n  // to be.\n  var remnant = new Buffer(_this.pos);\n  _this.bufToStore.copy(remnant, 0, 0, _this.pos);\n  _this.md5.update(remnant);\n  var doc = createChunkDoc(_this.id, _this.n, remnant);\n\n  // If the stream was aborted, do not write remnant\n  if (checkAborted(_this, callback)) {\n    return false;\n  }\n\n  _this.chunks.insert(doc, getWriteOptions(_this), function(error) {\n    if (error) {\n      return __handleError(_this, error);\n    }\n    --_this.state.outstandingRequests;\n    checkDone(_this);\n  });\n}\n\n/**\n * @ignore\n */\n\nfunction checkAborted(_this, callback) {\n  if (_this.state.aborted) {\n    if(typeof callback == 'function') {\n      callback(new Error('this stream has been aborted'));\n    }\n    return true;\n  }\n  return false;\n}\n"]}
{"version":3,"sources":["pool.js"],"names":[],"mappings":"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","file":"pool-compiled.js","sourcesContent":["\"use strict\";\n\nvar inherits = require('util').inherits,\n  EventEmitter = require('events').EventEmitter,\n  Connection = require('./connection'),\n  MongoError = require('../error'),\n  Logger = require('./logger'),\n  f = require('util').format,\n  Query = require('./commands').Query,\n  CommandResult = require('./command_result'),\n  assign = require('../topologies/shared').assign;\n\nvar MongoCR = require('../auth/mongocr')\n  , X509 = require('../auth/x509')\n  , Plain = require('../auth/plain')\n  , GSSAPI = require('../auth/gssapi')\n  , SSPI = require('../auth/sspi')\n  , ScramSHA1 = require('../auth/scram');\n\nvar DISCONNECTED = 'disconnected';\nvar CONNECTING = 'connecting';\nvar CONNECTED = 'connected';\nvar DESTROYING = 'destroying';\nvar DESTROYED = 'destroyed';\n\nvar _id = 0;\n\n/**\n * Creates a new Pool instance\n * @class\n * @param {string} options.host The server host\n * @param {number} options.port The server port\n * @param {number} [options.size=1] Max server connection pool size\n * @param {boolean} [options.reconnect=true] Server will attempt to reconnect on loss of connection\n * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times\n * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n * @param {number} [options.keepAliveInitialDelay=0] Initial delay before TCP keep alive enabled\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\n * @param {number} [options.connectionTimeout=0] TCP Connection timeout setting\n * @param {number} [options.socketTimeout=0] TCP Socket timeout setting\n * @param {number} [options.monitoringSocketTimeout=30000] TCP Socket timeout setting for replicaset monitoring socket\n * @param {boolean} [options.ssl=false] Use SSL for connection\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\n * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\n * @param {Buffer} [options.key] SSL Key file binary buffer\n * @param {string} [options.passPhrase] SSL Certificate pass phrase\n * @param {boolean} [options.rejectUnauthorized=false] Reject unauthorized server certificates\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\n * @fires Pool#connect\n * @fires Pool#close\n * @fires Pool#error\n * @fires Pool#timeout\n * @fires Pool#parseError\n * @return {Pool} A cursor instance\n */\nvar Pool = function(options) {\n  // Add event listener\n  EventEmitter.call(this);\n  // Add the options\n  this.options = assign({\n    // Host and port settings\n    host: 'localhost',\n    port: 27017,\n    // Pool default max size\n    size: 5,\n    // socket settings\n    connectionTimeout: 30000,\n    socketTimeout: 30000,\n    keepAlive: true,\n    keepAliveInitialDelay: 0,\n    noDelay: true,\n    // SSL Settings\n    ssl: false, checkServerIdentity: true,\n    ca: null, crl: null, cert: null, key: null, passPhrase: null,\n    rejectUnauthorized: false,\n    promoteLongs: true,\n    promoteValues: true,\n    promoteBuffers: false,\n    // Reconnection options\n    reconnect: true,\n    reconnectInterval: 1000,\n    reconnectTries: 30,\n    // Enable domains\n    domainsEnabled: false\n  }, options);\n\n  // Identification information\n  this.id = _id++;\n  // Current reconnect retries\n  this.retriesLeft = this.options.reconnectTries;\n  this.reconnectId = null;\n  // No bson parser passed in\n  if(!options.bson || (options.bson\n    && (typeof options.bson.serialize != 'function'\n    || typeof options.bson.deserialize != 'function'))) {\n      throw new Error(\"must pass in valid bson parser\");\n  }\n\n  // Logger instance\n  this.logger = Logger('Pool', options);\n  // Pool state\n  this.state = DISCONNECTED;\n  // Connections\n  this.availableConnections = [];\n  this.inUseConnections = [];\n  this.connectingConnections = [];\n  // Currently executing\n  this.executing = false;\n  // Operation work queue\n  this.queue = [];\n\n  // All the authProviders\n  this.authProviders = options.authProviders || {\n      'mongocr': new MongoCR(options.bson), 'x509': new X509(options.bson)\n    , 'plain': new Plain(options.bson), 'gssapi': new GSSAPI(options.bson)\n    , 'sspi': new SSPI(options.bson), 'scram-sha-1': new ScramSHA1(options.bson)\n  }\n\n  // Contains the reconnect connection\n  this.reconnectConnection = null;\n\n  // Are we currently authenticating\n  this.authenticating = false;\n  this.loggingout = false;\n  this.nonAuthenticatedConnections = [];\n  this.authenticatingTimestamp = null;\n  // Number of consecutive timeouts caught\n  this.numberOfConsecutiveTimeouts = 0;\n  // Current pool Index\n  this.connectionIndex = 0;\n}\n\ninherits(Pool, EventEmitter);\n\nObject.defineProperty(Pool.prototype, 'size', {\n  enumerable:true,\n  get: function() { return this.options.size; }\n});\n\nObject.defineProperty(Pool.prototype, 'connectionTimeout', {\n  enumerable:true,\n  get: function() { return this.options.connectionTimeout; }\n});\n\nObject.defineProperty(Pool.prototype, 'socketTimeout', {\n  enumerable:true,\n  get: function() { return this.options.socketTimeout; }\n});\n\nfunction stateTransition(self, newState) {\n  var legalTransitions = {\n    'disconnected': [CONNECTING, DESTROYING, DISCONNECTED],\n    'connecting': [CONNECTING, DESTROYING, CONNECTED, DISCONNECTED],\n    'connected': [CONNECTED, DISCONNECTED, DESTROYING],\n    'destroying': [DESTROYING, DESTROYED],\n    'destroyed': [DESTROYED]\n  }\n\n  // Get current state\n  var legalStates = legalTransitions[self.state];\n  if(legalStates && legalStates.indexOf(newState) != -1) {\n    self.state = newState;\n  } else {\n    self.logger.error(f('Pool with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]'\n      , self.id, self.state, newState, legalStates));\n  }\n}\n\nfunction authenticate(pool, auth, connection, cb) {\n  if(auth[0] === undefined) return cb(null);\n  // We need to authenticate the server\n  var mechanism = auth[0];\n  var db = auth[1];\n  // Validate if the mechanism exists\n  if(!pool.authProviders[mechanism]) {\n    throw new MongoError(f('authMechanism %s not supported', mechanism));\n  }\n\n  // Get the provider\n  var provider = pool.authProviders[mechanism];\n\n  // Authenticate using the provided mechanism\n  provider.auth.apply(provider, [write(pool), [connection], db].concat(auth.slice(2)).concat([cb]));\n}\n\n// The write function used by the authentication mechanism (bypasses external)\nfunction write(self) {\n  return function(connection, command, callback) {\n    // Get the raw buffer\n    // Ensure we stop auth if pool was destroyed\n    if(self.state == DESTROYED || self.state == DESTROYING) {\n      return callback(new MongoError('pool destroyed'));\n    }\n\n    // Set the connection workItem callback\n    connection.workItems.push({\n      cb: callback, command: true, requestId: command.requestId\n    });\n\n    // Write the buffer out to the connection\n    connection.write(command.toBin());\n  };\n}\n\n\nfunction reauthenticate(pool, connection, cb) {\n  // Authenticate\n  function authenticateAgainstProvider(pool, connection, providers, cb) {\n    // Finished re-authenticating against providers\n    if(providers.length == 0) return cb();\n    // Get the provider name\n    var provider = pool.authProviders[providers.pop()];\n\n    // Auth provider\n    provider.reauthenticate(write(pool), [connection], function(err) {\n      // We got an error return immediately\n      if(err) return cb(err);\n      // Continue authenticating the connection\n      authenticateAgainstProvider(pool, connection, providers, cb);\n    });\n  }\n\n  // Start re-authenticating process\n  authenticateAgainstProvider(pool, connection, Object.keys(pool.authProviders), cb);\n}\n\nfunction connectionFailureHandler(self, event) {\n  return function(err) {\n    if (this._connectionFailHandled) return;\n    this._connectionFailHandled = true;\n    // Destroy the connection\n    this.destroy();\n\n    // Remove the connection\n    removeConnection(self, this);\n\n    // Flush all work Items on this connection\n    while(this.workItems.length > 0) {\n      var workItem = this.workItems.shift();\n      // if(workItem.cb) workItem.cb(err);\n      if(workItem.cb) workItem.cb(err);\n    }\n\n    // Did we catch a timeout, increment the numberOfConsecutiveTimeouts\n    if(event == 'timeout') {\n      self.numberOfConsecutiveTimeouts = self.numberOfConsecutiveTimeouts + 1;\n\n      // Have we timed out more than reconnectTries in a row ?\n      // Force close the pool as we are trying to connect to tcp sink hole\n      if(self.numberOfConsecutiveTimeouts > self.options.reconnectTries) {\n        self.numberOfConsecutiveTimeouts = 0;\n        // Destroy all connections and pool\n        self.destroy(true);\n        // Emit close event\n        return self.emit('close', self);\n      }\n    }\n\n    // No more socket available propegate the event\n    if(self.socketCount() == 0) {\n      if(self.state != DESTROYED && self.state != DESTROYING) {\n        stateTransition(self, DISCONNECTED);\n      }\n\n      // Do not emit error events, they are always close events\n      // do not trigger the low level error handler in node\n      event = event == 'error' ? 'close' : event;\n      self.emit(event, err);\n    }\n\n    // Start reconnection attempts\n    if(!self.reconnectId && self.options.reconnect) {\n      self.reconnectId = setTimeout(attemptReconnect(self), self.options.reconnectInterval);\n    }\n  };\n}\n\nfunction attemptReconnect(self) {\n  return function() {\n    self.emit('attemptReconnect', self);\n    if(self.state == DESTROYED || self.state == DESTROYING) return;\n\n    // We are connected do not try again\n    if(self.isConnected()) {\n      self.reconnectId = null;\n      return;\n    }\n\n    // If we have failure schedule a retry\n    function _connectionFailureHandler(self) {\n      return function() {\n        if (this._connectionFailHandled) return;\n        this._connectionFailHandled = true;\n        // Destroy the connection\n        this.destroy();\n        // Count down the number of reconnects\n        self.retriesLeft = self.retriesLeft - 1;\n        // How many retries are left\n        if(self.retriesLeft == 0) {\n          // Destroy the instance\n          self.destroy();\n          // Emit close event\n          self.emit('reconnectFailed'\n            , new MongoError(f('failed to reconnect after %s attempts with interval %s ms', self.options.reconnectTries, self.options.reconnectInterval)));\n        } else {\n          self.reconnectId = setTimeout(attemptReconnect(self), self.options.reconnectInterval);\n        }\n      }\n    }\n\n    // Got a connect handler\n    function _connectHandler(self) {\n      return function() {\n        // Assign\n        var connection = this;\n\n        // Pool destroyed stop the connection\n        if(self.state == DESTROYED || self.state == DESTROYING) {\n          return connection.destroy();\n        }\n\n        // Clear out all handlers\n        handlers.forEach(function(event) {\n          connection.removeAllListeners(event);\n        });\n\n        // Reset reconnect id\n        self.reconnectId = null;\n\n        // Apply pool connection handlers\n        connection.on('error', connectionFailureHandler(self, 'error'));\n        connection.on('close', connectionFailureHandler(self, 'close'));\n        connection.on('timeout', connectionFailureHandler(self, 'timeout'));\n        connection.on('parseError', connectionFailureHandler(self, 'parseError'));\n\n        // Apply any auth to the connection\n        reauthenticate(self, this, function() {\n          // Reset retries\n          self.retriesLeft = self.options.reconnectTries;\n          // Push to available connections\n          self.availableConnections.push(connection);\n          // Set the reconnectConnection to null\n          self.reconnectConnection = null;\n          // Emit reconnect event\n          self.emit('reconnect', self);\n          // Trigger execute to start everything up again\n          _execute(self)();\n        });\n      }\n    }\n\n    // Create a connection\n    self.reconnectConnection = new Connection(messageHandler(self), self.options);\n    // Add handlers\n    self.reconnectConnection.on('close', _connectionFailureHandler(self, 'close'));\n    self.reconnectConnection.on('error', _connectionFailureHandler(self, 'error'));\n    self.reconnectConnection.on('timeout', _connectionFailureHandler(self, 'timeout'));\n    self.reconnectConnection.on('parseError', _connectionFailureHandler(self, 'parseError'));\n    // On connection\n    self.reconnectConnection.on('connect', _connectHandler(self));\n    // Attempt connection\n    self.reconnectConnection.connect();\n  }\n}\n\nfunction moveConnectionBetween(connection, from, to) {\n  var index = from.indexOf(connection);\n  // Move the connection from connecting to available\n  if(index != -1) {\n    from.splice(index, 1);\n    to.push(connection);\n  }\n}\n\nfunction messageHandler(self) {\n  return function(message, connection) {\n    // workItem to execute\n    var workItem = null;\n\n    // Locate the workItem\n    for(var i = 0; i < connection.workItems.length; i++) {\n      if(connection.workItems[i].requestId == message.responseTo) {\n        // Get the callback\n        workItem = connection.workItems[i];\n        // Remove from list of workItems\n        connection.workItems.splice(i, 1);\n      }\n    }\n\n\n    // Reset timeout counter\n    self.numberOfConsecutiveTimeouts = 0;\n\n    // Reset the connection timeout if we modified it for\n    // this operation\n    if(workItem.socketTimeout) {\n      connection.resetSocketTimeout();\n    }\n\n    // Log if debug enabled\n    if(self.logger.isDebug()) {\n      self.logger.debug(f('message [%s] received from %s:%s'\n        , message.raw.toString('hex'), self.options.host, self.options.port));\n    }\n\n    // Authenticate any straggler connections\n    function authenticateStragglers(self, connection, callback) {\n      // Get any non authenticated connections\n      var connections = self.nonAuthenticatedConnections.slice(0);\n      var nonAuthenticatedConnections = self.nonAuthenticatedConnections;\n      self.nonAuthenticatedConnections = [];\n\n      // Establish if the connection need to be authenticated\n      // Add to authentication list if\n      // 1. we were in an authentication process when the operation was executed\n      // 2. our current authentication timestamp is from the workItem one, meaning an auth has happened\n      if(connection.workItems.length == 1 && (connection.workItems[0].authenticating == true\n        || (typeof connection.workItems[0].authenticatingTimestamp == 'number'\n            && connection.workItems[0].authenticatingTimestamp != self.authenticatingTimestamp))) {\n        // Add connection to the list\n        connections.push(connection);\n      }\n\n      // No connections need to be re-authenticated\n      if(connections.length == 0) {\n        // Release the connection back to the pool\n        moveConnectionBetween(connection, self.inUseConnections, self.availableConnections);\n        // Finish\n        return callback();\n      }\n\n      // Apply re-authentication to all connections before releasing back to pool\n      var connectionCount = connections.length;\n      // Authenticate all connections\n      for(var i = 0; i < connectionCount; i++) {\n        reauthenticate(self, connections[i], function() {\n          connectionCount = connectionCount - 1;\n\n          if(connectionCount == 0) {\n            // Put non authenticated connections in available connections\n            self.availableConnections = self.availableConnections.concat(nonAuthenticatedConnections);\n            // Release the connection back to the pool\n            moveConnectionBetween(connection, self.inUseConnections, self.availableConnections);\n            // Return\n            callback();\n          }\n        });\n      }\n    }\n\n    function handleOperationCallback(self, cb, err, result) {\n      // No domain enabled\n      if(!self.options.domainsEnabled) {\n        return process.nextTick(function() {\n          return cb(err, result);\n        });\n      }\n\n      // Domain enabled just call the callback\n      cb(err, result);\n    }\n\n    authenticateStragglers(self, connection, function() {\n      // Keep executing, ensure current message handler does not stop execution\n      if(!self.executing) {\n        process.nextTick(function() {\n          _execute(self)();\n        });\n      }\n\n      // Time to dispatch the message if we have a callback\n      if(!workItem.immediateRelease) {\n        try {\n          // Parse the message according to the provided options\n          message.parse(workItem);\n        } catch(err) {\n          return handleOperationCallback(self, workItem.cb, MongoError.create(err));\n        }\n\n        // Establish if we have an error\n        if(workItem.command && message.documents[0] && (message.documents[0].ok == 0 || message.documents[0]['$err']\n        || message.documents[0]['errmsg'] || message.documents[0]['code'])) {\n          return handleOperationCallback(self, workItem.cb, MongoError.create(message.documents[0]));\n        }\n\n        // Add the connection details\n        message.hashedName = connection.hashedName;\n\n        // Return the documents\n        handleOperationCallback(self, workItem.cb, null, new CommandResult(workItem.fullResult ? message : message.documents[0], connection, message));\n      }\n    });\n  }\n}\n\n/**\n * Return the total socket count in the pool.\n * @method\n * @return {Number} The number of socket available.\n */\nPool.prototype.socketCount = function() {\n  return this.availableConnections.length\n    + this.inUseConnections.length;\n    // + this.connectingConnections.length;\n}\n\n/**\n * Return all pool connections\n * @method\n * @return {Connection[]} The pool connections\n */\nPool.prototype.allConnections = function() {\n  return this.availableConnections\n    .concat(this.inUseConnections)\n    .concat(this.connectingConnections);\n}\n\n/**\n * Get a pool connection (round-robin)\n * @method\n * @return {Connection}\n */\nPool.prototype.get = function() {\n  return this.allConnections()[0];\n}\n\n/**\n * Is the pool connected\n * @method\n * @return {boolean}\n */\nPool.prototype.isConnected = function() {\n  // We are in a destroyed state\n  if(this.state == DESTROYED || this.state == DESTROYING) {\n    return false;\n  }\n\n  // Get connections\n  var connections = this.availableConnections\n    .concat(this.inUseConnections);\n\n  // Check if we have any connected connections\n  for(var i = 0; i < connections.length; i++) {\n    if(connections[i].isConnected()) return true;\n  }\n\n  // Might be authenticating, but we are still connected\n  if(connections.length == 0 && this.authenticating) {\n    return true\n  }\n\n  // Not connected\n  return false;\n}\n\n/**\n * Was the pool destroyed\n * @method\n * @return {boolean}\n */\nPool.prototype.isDestroyed = function() {\n  return this.state == DESTROYED || this.state == DESTROYING;\n}\n\n/**\n * Is the pool in a disconnected state\n * @method\n * @return {boolean}\n */\nPool.prototype.isDisconnected = function() {\n  return this.state == DISCONNECTED;\n}\n\n/**\n * Connect pool\n * @method\n */\nPool.prototype.connect = function() {\n  if(this.state != DISCONNECTED) {\n    throw new MongoError('connection in unlawful state ' + this.state);\n  }\n\n  var self = this;\n  // Transition to connecting state\n  stateTransition(this, CONNECTING);\n  // Create an array of the arguments\n  var args = Array.prototype.slice.call(arguments, 0);\n  // Create a connection\n  var connection = new Connection(messageHandler(self), this.options);\n  // Add to list of connections\n  this.connectingConnections.push(connection);\n  // Add listeners to the connection\n  connection.once('connect', function(connection) {\n    if(self.state == DESTROYED || self.state == DESTROYING) return self.destroy();\n\n    // If we are in a topology, delegate the auth to it\n    // This is to avoid issues where we would auth against an\n    // arbiter\n    if(self.options.inTopology) {\n      // Set connected mode\n      stateTransition(self, CONNECTED);\n\n      // Move the active connection\n      moveConnectionBetween(connection, self.connectingConnections, self.availableConnections);\n\n      // Emit the connect event\n      return self.emit('connect', self);      \n    }\n\n    // Apply any store credentials\n    reauthenticate(self, connection, function(err) {\n      if(self.state == DESTROYED || self.state == DESTROYING) return self.destroy();\n\n      // We have an error emit it\n      if(err) {\n        // Destroy the pool\n        self.destroy();\n        // Emit the error\n        return self.emit('error', err);\n      }\n\n      // Authenticate\n      authenticate(self, args, connection, function(err) {\n        if(self.state == DESTROYED || self.state == DESTROYING) return self.destroy();\n\n        // We have an error emit it\n        if(err) {\n          // Destroy the pool\n          self.destroy();\n          // Emit the error\n          return self.emit('error', err);\n        }\n        // Set connected mode\n        stateTransition(self, CONNECTED);\n\n        // Move the active connection\n        moveConnectionBetween(connection, self.connectingConnections, self.availableConnections);\n\n        // Emit the connect event\n        self.emit('connect', self);\n      });\n    });\n  });\n\n  // Add error handlers\n  connection.once('error', connectionFailureHandler(this, 'error'));\n  connection.once('close', connectionFailureHandler(this, 'close'));\n  connection.once('timeout', connectionFailureHandler(this, 'timeout'));\n  connection.once('parseError', connectionFailureHandler(this, 'parseError'));\n\n  try {\n    connection.connect();\n  } catch(err) {\n    // SSL or something threw on connect\n    process.nextTick(function() {\n      self.emit('error', err);\n    });\n  }\n}\n\n/**\n * Authenticate using a specified mechanism\n * @method\n * @param {string} mechanism The Auth mechanism we are invoking\n * @param {string} db The db we are invoking the mechanism against\n * @param {...object} param Parameters for the specific mechanism\n * @param {authResultCallback} callback A callback function\n */\nPool.prototype.auth = function(mechanism) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 0);\n  var callback = args.pop();\n\n  // If we don't have the mechanism fail\n  if(self.authProviders[mechanism] == null && mechanism != 'default') {\n    throw new MongoError(f(\"auth provider %s does not exist\", mechanism));\n  }\n\n  // Signal that we are authenticating a new set of credentials\n  this.authenticating = true;\n  this.authenticatingTimestamp = new Date().getTime();\n\n  // Authenticate all live connections\n  function authenticateLiveConnections(self, args, cb) {\n    // Get the current viable connections\n    var connections = self.allConnections();\n    // Allow nothing else to use the connections while we authenticate them\n    self.availableConnections = [];\n\n    var connectionsCount = connections.length;\n    var error = null;\n    // No connections available, return\n    if(connectionsCount == 0) {\n      self.authenticating = false;\n      return callback(null);\n    }\n\n    // Authenticate the connections\n    for(var i = 0; i < connections.length; i++) {\n      authenticate(self, args, connections[i], function(err) {\n        connectionsCount = connectionsCount - 1;\n\n        // Store the error\n        if(err) error = err;\n\n        // Processed all connections\n        if(connectionsCount == 0) {\n          // Auth finished\n          self.authenticating = false;\n          // Add the connections back to available connections\n          self.availableConnections = self.availableConnections.concat(connections);\n          // We had an error, return it\n          if(error) {\n            // Log the error\n            if(self.logger.isError()) {\n              self.logger.error(f('[%s] failed to authenticate against server %s:%s'\n                , self.id, self.options.host, self.options.port));\n            }\n\n            return cb(error);\n          }\n          cb(null);\n        }\n      });\n    }\n  }\n\n  // Wait for a logout in process to happen\n  function waitForLogout(self, cb) {\n    if(!self.loggingout) return cb();\n    setTimeout(function() {\n      waitForLogout(self, cb);\n    }, 1)\n  }\n\n  // Wait for loggout to finish\n  waitForLogout(self, function() {\n    // Authenticate all live connections\n    authenticateLiveConnections(self, args, function(err) {\n      // Credentials correctly stored in auth provider if successful\n      // Any new connections will now reauthenticate correctly\n      self.authenticating = false;\n      // Return after authentication connections\n      callback(err);\n    });\n  });\n}\n\n/**\n * Logout all users against a database\n * @method\n * @param {string} dbName The database name\n * @param {authResultCallback} callback A callback function\n */\nPool.prototype.logout = function(dbName, callback) {\n  var self = this;\n  if(typeof dbName != 'string') {\n    throw new MongoError('logout method requires a db name as first argument');\n  }\n\n  if(typeof callback != 'function') {\n    throw new MongoError('logout method requires a callback');\n  }\n\n  // Indicate logout in process\n  this.loggingout = true;\n\n  // Get all relevant connections\n  var connections = self.availableConnections.concat(self.inUseConnections);\n  var count = connections.length;\n  // Store any error\n  var error = null;\n\n  // Send logout command over all the connections\n  for(var i = 0; i < connections.length; i++) {\n    write(self)(connections[i], new Query(this.options.bson\n      , f('%s.$cmd', dbName)\n      , {logout:1}, {numberToSkip: 0, numberToReturn: 1}), function(err) {\n      count = count - 1;\n      if(err) error = err;\n\n      if(count == 0) {\n        self.loggingout = false;\n        callback(error);\n      }\n    });\n  }\n}\n\n/**\n * Unref the pool\n * @method\n */\nPool.prototype.unref = function() {\n  // Get all the known connections\n  var connections = this.availableConnections\n    .concat(this.inUseConnections)\n    .concat(this.connectingConnections);\n  connections.forEach(function(c) {\n    c.unref();\n  });\n}\n\n// Events\nvar events = ['error', 'close', 'timeout', 'parseError', 'connect'];\n\n// Destroy the connections\nfunction destroy(self, connections) {\n  // Destroy all connections\n  connections.forEach(function(c) {\n    // Remove all listeners\n    for(var i = 0; i < events.length; i++) {\n      c.removeAllListeners(events[i]);\n    }\n    // Destroy connection\n    c.destroy();\n  });\n\n  // Zero out all connections\n  self.inUseConnections = [];\n  self.availableConnections = [];\n  self.nonAuthenticatedConnections = [];\n  self.connectingConnections = [];\n\n  // Set state to destroyed\n  stateTransition(self, DESTROYED);\n}\n\n/**\n * Destroy pool\n * @method\n */\nPool.prototype.destroy = function(force) {\n  var self = this;\n  // Do not try again if the pool is already dead\n  if(this.state == DESTROYED || self.state == DESTROYING) return;\n  // Set state to destroyed\n  stateTransition(this, DESTROYING);\n\n  // Are we force closing\n  if(force) {\n    // Get all the known connections\n    var connections = self.availableConnections\n      .concat(self.inUseConnections)\n      .concat(self.nonAuthenticatedConnections)\n      .concat(self.connectingConnections);\n    return destroy(self, connections);\n  }\n\n  // Clear out the reconnect if set\n  if (this.reconnectId) {\n    clearTimeout(this.reconnectId);\n  }\n\n  // If we have a reconnect connection running, close\n  // immediately\n  if (this.reconnectConnection) {\n    this.reconnectConnection.destroy();\n  }\n\n  // Wait for the operations to drain before we close the pool\n  function checkStatus() {\n    flushMonitoringOperations(self.queue);\n\n    if(self.queue.length == 0) {\n      // Get all the known connections\n      var connections = self.availableConnections\n        .concat(self.inUseConnections)\n        .concat(self.nonAuthenticatedConnections)\n        .concat(self.connectingConnections);\n\n      // Check if we have any in flight operations\n      for(var i = 0; i < connections.length; i++) {\n        // There is an operation still in flight, reschedule a\n        // check waiting for it to drain\n        if(connections[i].workItems.length > 0) {\n          return setTimeout(checkStatus, 1);\n        }\n      }\n\n      destroy(self, connections);\n    // } else if (self.queue.length > 0 && !this.reconnectId) {\n      \n    } else {\n      // Ensure we empty the queue\n      _execute(self)();\n      // Set timeout\n      setTimeout(checkStatus, 1);\n    }\n  }\n\n  // Initiate drain of operations\n  checkStatus();\n}\n\n/**\n * Write a message to MongoDB\n * @method\n * @return {Connection}\n */\nPool.prototype.write = function(commands, options, cb) {\n  var self = this;\n  // Ensure we have a callback\n  if(typeof options == 'function') {\n    cb = options;\n  }\n\n  // Always have options\n  options = options || {};\n\n  // Pool was destroyed error out\n  if(this.state == DESTROYED || this.state == DESTROYING) {\n    // Callback with an error\n    if(cb) {\n      try {\n        cb(new MongoError('pool destroyed'));\n      } catch(err) {\n        process.nextTick(function() {\n          throw err;\n        });\n      }\n    }\n\n    return;\n  }\n\n  if(this.options.domainsEnabled\n    && process.domain && typeof cb === \"function\") {\n    // if we have a domain bind to it\n    var oldCb = cb;\n    cb = process.domain.bind(function() {\n      // v8 - argumentsToArray one-liner\n      var args = new Array(arguments.length); for(var i = 0; i < arguments.length; i++) { args[i] = arguments[i]; }\n      // bounce off event loop so domain switch takes place\n      process.nextTick(function() {\n        oldCb.apply(null, args);\n      });\n    });\n  }\n\n  // Do we have an operation\n  var operation = {\n    cb: cb, raw: false, promoteLongs: true, promoteValues: true, promoteBuffers: false, fullResult: false\n  };\n\n  var buffer = null\n\n  if(Array.isArray(commands)) {\n    buffer = [];\n\n    for(var i = 0; i < commands.length; i++) {\n      buffer.push(commands[i].toBin());\n    }\n\n    // Get the requestId\n    operation.requestId = commands[commands.length - 1].requestId;\n  } else {\n    operation.requestId = commands.requestId;\n    buffer = commands.toBin();\n  }\n\n  // Set the buffers\n  operation.buffer = buffer;\n\n  // Set the options for the parsing\n  operation.promoteLongs = typeof options.promoteLongs == 'boolean' ? options.promoteLongs : true;\n  operation.promoteValues = typeof options.promoteValues == 'boolean' ? options.promoteValues : true;\n  operation.promoteBuffers = typeof options.promoteBuffers == 'boolean' ? options.promoteBuffers : false;\n  operation.raw = typeof options.raw == 'boolean' ? options.raw : false;\n  operation.immediateRelease = typeof options.immediateRelease == 'boolean' ? options.immediateRelease : false;\n  operation.documentsReturnedIn = options.documentsReturnedIn;\n  operation.command = typeof options.command == 'boolean' ? options.command : false;\n  operation.fullResult = typeof options.fullResult == 'boolean' ? options.fullResult : false;\n  operation.noResponse = typeof options.noResponse == 'boolean' ? options.noResponse : false;\n  // operation.requestId = options.requestId;\n\n  // Optional per operation socketTimeout\n  operation.socketTimeout = options.socketTimeout;\n  operation.monitoring = options.monitoring;\n  // Custom socket Timeout\n  if(options.socketTimeout) {\n    operation.socketTimeout = options.socketTimeout;\n  }\n\n  // We need to have a callback function unless the message returns no response\n  if(!(typeof cb == 'function') && !options.noResponse) {\n    throw new MongoError('write method must provide a callback');\n  }\n\n  // If we have a monitoring operation schedule as the very first operation\n  // Otherwise add to back of queue\n  if(options.monitoring) {\n    this.queue.unshift(operation);\n  } else {\n    this.queue.push(operation);\n  }\n\n  // Attempt to execute the operation\n  if(!self.executing) {\n    process.nextTick(function() {\n      _execute(self)();\n    });\n  }\n}\n\n// Remove connection method\nfunction remove(connection, connections) {\n  for(var i = 0; i < connections.length; i++) {\n    if(connections[i] === connection) {\n      connections.splice(i, 1);\n      return true;\n    }\n  }\n}\n\nfunction removeConnection(self, connection) {\n  if(remove(connection, self.availableConnections)) return;\n  if(remove(connection, self.inUseConnections)) return;\n  if(remove(connection, self.connectingConnections)) return;\n  if(remove(connection, self.nonAuthenticatedConnections)) return;\n}\n\n// All event handlers\nvar handlers = [\"close\", \"message\", \"error\", \"timeout\", \"parseError\", \"connect\"];\n\nfunction _createConnection(self) {\n  if(self.state == DESTROYED || self.state == DESTROYING) {\n    return;\n  }\n  var connection = new Connection(messageHandler(self), self.options);\n\n  // Push the connection\n  self.connectingConnections.push(connection);\n\n  // Handle any errors\n  var tempErrorHandler = function(_connection) {\n    return function() {\n      // Destroy the connection\n      _connection.destroy();\n      // Remove the connection from the connectingConnections list\n      removeConnection(self, _connection);\n      // Start reconnection attempts\n      if(!self.reconnectId && self.options.reconnect) {\n        self.reconnectId = setTimeout(attemptReconnect(self), self.options.reconnectInterval);\n      }\n    }\n  }\n\n  // Handle successful connection\n  var tempConnectHandler = function(_connection) {\n    return function() {\n      // Destroyed state return\n      if(self.state == DESTROYED || self.state == DESTROYING) {\n        // Remove the connection from the list\n        removeConnection(self, _connection);\n        return _connection.destroy();\n      }\n\n      // Destroy all event emitters\n      handlers.forEach(function(e) {\n        _connection.removeAllListeners(e);\n      });\n\n      // Add the final handlers\n      _connection.once('close', connectionFailureHandler(self, 'close'));\n      _connection.once('error', connectionFailureHandler(self, 'error'));\n      _connection.once('timeout', connectionFailureHandler(self, 'timeout'));\n      _connection.once('parseError', connectionFailureHandler(self, 'parseError'));\n\n      // Signal\n      reauthenticate(self, _connection, function(err) {\n        if(self.state == DESTROYED || self.state == DESTROYING) {\n          return _connection.destroy();\n        }\n        // Remove the connection from the connectingConnections list\n        removeConnection(self, _connection);\n\n        // Handle error\n        if(err) {\n          return _connection.destroy();\n        }\n\n        // If we are c at the moment\n        // Do not automatially put in available connections\n        // As we need to apply the credentials first\n        if(self.authenticating) {\n          self.nonAuthenticatedConnections.push(_connection);\n        } else {\n          // Push to available\n          self.availableConnections.push(_connection);\n          // Execute any work waiting\n          _execute(self)();\n        }\n      });\n    }\n  }\n\n  // Add all handlers\n  connection.once('close', tempErrorHandler(connection));\n  connection.once('error', tempErrorHandler(connection));\n  connection.once('timeout', tempErrorHandler(connection));\n  connection.once('parseError', tempErrorHandler(connection));\n  connection.once('connect', tempConnectHandler(connection));\n\n  // Start connection\n  connection.connect();\n}\n\nfunction flushMonitoringOperations(queue) {\n  for(var i = 0; i < queue.length; i++) {\n    if(queue[i].monitoring) {\n      var workItem = queue[i];\n      queue.splice(i, 1);\n      workItem.cb(new MongoError({ message: 'no connection available for monitoring', driver:true }));\n    }\n  }\n}\n\nfunction _execute(self) {\n  return function() {\n    if(self.state == DESTROYED) return;\n    // Already executing, skip\n    if(self.executing) return;\n    // Set pool as executing\n    self.executing = true;\n\n    // Wait for auth to clear before continuing\n    function waitForAuth(cb) {\n      if(!self.authenticating) return cb();\n      // Wait for a milisecond and try again\n      setTimeout(function() {\n        waitForAuth(cb);\n      }, 1);\n    }\n\n    // Block on any auth in process\n    waitForAuth(function() {\n      // New pool connections are in progress, wait them to finish\n      // before executing any more operation to ensure distribution of\n      // operations\n      if(self.connectingConnections.length > 0) {\n        return;\n      }\n\n      // As long as we have available connections\n      while(true) {\n        // Total availble connections\n        var totalConnections = self.availableConnections.length\n          + self.connectingConnections.length\n          + self.inUseConnections.length;\n\n        // No available connections available, flush any monitoring ops\n        if(self.availableConnections.length == 0) {\n          // Flush any monitoring operations\n          flushMonitoringOperations(self.queue);\n          break;\n        }\n\n        // No queue break\n        if(self.queue.length == 0) {\n          break;\n        }\n\n        // Get a connection\n        var connection = null;\n\n        // Locate all connections that have no work\n        var connections = [];\n        // Get a list of all connections\n        for(var i = 0; i < self.availableConnections.length; i++) {\n          if(self.availableConnections[i].workItems.length == 0) {\n            connections.push(self.availableConnections[i]);\n          }\n        }\n\n        // No connection found that has no work on it, just pick one for pipelining\n        if(connections.length == 0) {\n          connection = self.availableConnections[self.connectionIndex++ % self.availableConnections.length];\n        } else {\n          connection = connections[self.connectionIndex++ % connections.length];\n        }\n\n        // Is the connection connected\n        if(connection.isConnected()) {\n          // Get the next work item\n          var workItem = self.queue.shift();\n\n          // If we are monitoring we need to use a connection that is not\n          // running another operation to avoid socket timeout changes\n          // affecting an existing operation\n          if (workItem.monitoring) {\n            var foundValidConnection = false;\n\n            for (var i = 0; i < self.availableConnections.length; i++) {\n              // If the connection is connected\n              // And there are no pending workItems on it\n              // Then we can safely use it for monitoring.\n              if(self.availableConnections[i].isConnected()\n                && self.availableConnections[i].workItems.length == 0) {\n                  foundValidConnection = true;\n                  connection = self.availableConnections[i];\n                  break;\n                }\n            }\n\n            // No safe connection found, attempt to grow the connections\n            // if possible and break from the loop\n            if(!foundValidConnection) {\n              // Put workItem back on the queue\n              self.queue.unshift(workItem);\n\n              // Attempt to grow the pool if it's not yet maxsize\n              if(totalConnections < self.options.size\n                && self.queue.length > 0) {\n                // Create a new connection\n                _createConnection(self);\n              }\n\n              // Re-execute the operation\n              setTimeout(function() {\n                _execute(self)();\n              }, 10);\n\n              break;\n            }\n          }\n\n          // Don't execute operation until we have a full pool\n          if(totalConnections < self.options.size) {\n            // Connection has work items, then put it back on the queue\n            // and create a new connection\n            if(connection.workItems.length > 0) {\n              // Lets put the workItem back on the list\n              self.queue.unshift(workItem);\n              // Create a new connection\n              _createConnection(self);\n              // Break from the loop\n              break;\n            }\n          }\n\n          // Get actual binary commands\n          var buffer = workItem.buffer;\n\n          // Set current status of authentication process\n          workItem.authenticating = self.authenticating;\n          workItem.authenticatingTimestamp = self.authenticatingTimestamp;\n\n          // If we are monitoring take the connection of the availableConnections\n          if (workItem.monitoring) {\n            moveConnectionBetween(connection, self.availableConnections, self.inUseConnections);\n          }\n\n          // Track the executing commands on the mongo server\n          // as long as there is an expected response\n          if (! workItem.noResponse) {\n            connection.workItems.push(workItem);\n          }\n\n          // We have a custom socketTimeout\n          if(!workItem.immediateRelease && typeof workItem.socketTimeout == 'number') {\n            connection.setSocketTimeout(workItem.socketTimeout);\n          }\n\n          // Put operation on the wire\n          if(Array.isArray(buffer)) {\n            for(var i = 0; i < buffer.length; i++) {\n              connection.write(buffer[i])\n            }\n          } else {\n            connection.write(buffer);\n          }\n\n          if(workItem.immediateRelease && self.authenticating) {\n            self.nonAuthenticatedConnections.push(connection);\n          }\n        } else {\n          // Remove the disconnected connection\n          removeConnection(self, connection);\n          // Flush any monitoring operations in the queue, failing fast\n          flushMonitoringOperations(self.queue);\n        }\n      }\n    });\n\n    self.executing = false;\n  }\n}\n\n// Make execution loop available for testing\nPool._execute = _execute;\n\n/**\n * A server connect event, used to verify that the connection is up and running\n *\n * @event Pool#connect\n * @type {Pool}\n */\n\n/**\n * A server reconnect event, used to verify that pool reconnected.\n *\n * @event Pool#reconnect\n * @type {Pool}\n */\n\n/**\n * The server connection closed, all pool connections closed\n *\n * @event Pool#close\n * @type {Pool}\n */\n\n/**\n * The server connection caused an error, all pool connections closed\n *\n * @event Pool#error\n * @type {Pool}\n */\n\n/**\n * The server connection timed out, all pool connections closed\n *\n * @event Pool#timeout\n * @type {Pool}\n */\n\n/**\n * The driver experienced an invalid message, all pool connections closed\n *\n * @event Pool#parseError\n * @type {Pool}\n */\n\n/**\n * The driver attempted to reconnect\n *\n * @event Pool#attemptReconnect\n * @type {Pool}\n */\n\n/**\n * The driver exhausted all reconnect attempts\n *\n * @event Pool#reconnectFailed\n * @type {Pool}\n */\n\nmodule.exports = Pool;\n"]}
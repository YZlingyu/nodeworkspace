{"version":3,"sources":["castUpdate.js"],"names":[],"mappings":"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","file":"castUpdate-compiled.js","sourcesContent":["'use strict';\n\nvar StrictModeError = require('../../error/strict');\nvar utils = require('../../utils');\n\n/*!\n * Casts an update op based on the given schema\n *\n * @param {Schema} schema\n * @param {Object} obj\n * @param {Object} options\n * @param {Boolean} [options.overwrite] defaults to false\n * @param {Boolean|String} [options.strict] defaults to true\n * @return {Boolean} true iff the update is non-empty\n */\n\nmodule.exports = function castUpdate(schema, obj, options) {\n  if (!obj) {\n    return undefined;\n  }\n\n  var ops = Object.keys(obj);\n  var i = ops.length;\n  var ret = {};\n  var hasKeys;\n  var val;\n  var hasDollarKey = false;\n  var overwrite = options.overwrite;\n\n  while (i--) {\n    var op = ops[i];\n    // if overwrite is set, don't do any of the special $set stuff\n    if (op[0] !== '$' && !overwrite) {\n      // fix up $set sugar\n      if (!ret.$set) {\n        if (obj.$set) {\n          ret.$set = obj.$set;\n        } else {\n          ret.$set = {};\n        }\n      }\n      ret.$set[op] = obj[op];\n      ops.splice(i, 1);\n      if (!~ops.indexOf('$set')) ops.push('$set');\n    } else if (op === '$set') {\n      if (!ret.$set) {\n        ret[op] = obj[op];\n      }\n    } else {\n      ret[op] = obj[op];\n    }\n  }\n\n  // cast each value\n  i = ops.length;\n\n  // if we get passed {} for the update, we still need to respect that when it\n  // is an overwrite scenario\n  if (overwrite) {\n    hasKeys = true;\n  }\n\n  while (i--) {\n    op = ops[i];\n    val = ret[op];\n    hasDollarKey = hasDollarKey || op.charAt(0) === '$';\n    if (val &&\n        typeof val === 'object' &&\n        (!overwrite || hasDollarKey)) {\n      hasKeys |= walkUpdatePath(schema, val, op, options.strict);\n    } else if (overwrite && ret && typeof ret === 'object') {\n      // if we are just using overwrite, cast the query and then we will\n      // *always* return the value, even if it is an empty object. We need to\n      // set hasKeys above because we need to account for the case where the\n      // user passes {} and wants to clobber the whole document\n      // Also, _walkUpdatePath expects an operation, so give it $set since that\n      // is basically what we're doing\n      walkUpdatePath(schema, ret, '$set', options.strict);\n    } else {\n      var msg = 'Invalid atomic update value for ' + op + '. '\n          + 'Expected an object, received ' + typeof val;\n      throw new Error(msg);\n    }\n  }\n\n  return hasKeys && ret;\n};\n\n/*!\n * Walk each path of obj and cast its values\n * according to its schema.\n *\n * @param {Schema} schema\n * @param {Object} obj - part of a query\n * @param {String} op - the atomic operator ($pull, $set, etc)\n * @param {Boolean|String} strict\n * @param {String} pref - path prefix (internal only)\n * @return {Bool} true if this path has keys to update\n * @api private\n */\n\nfunction walkUpdatePath(schema, obj, op, strict, pref) {\n  var prefix = pref ? pref + '.' : '',\n      keys = Object.keys(obj),\n      i = keys.length,\n      hasKeys = false,\n      schematype,\n      key,\n      val;\n\n  var useNestedStrict = schema.options.useNestedStrict;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    if (val && val.constructor.name === 'Object') {\n      // watch for embedded doc schemas\n      schematype = schema._getSchema(prefix + key);\n      if (schematype && schematype.caster && op in castOps) {\n        // embedded doc schema\n        hasKeys = true;\n\n        if ('$each' in val) {\n          obj[key] = {\n            $each: castUpdateVal(schematype, val.$each, op)\n          };\n\n          if (val.$slice != null) {\n            obj[key].$slice = val.$slice | 0;\n          }\n\n          if (val.$sort) {\n            obj[key].$sort = val.$sort;\n          }\n\n          if (!!val.$position || val.$position === 0) {\n            obj[key].$position = val.$position;\n          }\n        } else {\n          obj[key] = castUpdateVal(schematype, val, op);\n        }\n      } else if (op === '$currentDate') {\n        // $currentDate can take an object\n        obj[key] = castUpdateVal(schematype, val, op);\n        hasKeys = true;\n      } else if (op in castOps && schematype) {\n        obj[key] = castUpdateVal(schematype, val, op);\n        hasKeys = true;\n      } else {\n        var pathToCheck = (prefix + key);\n        var v = schema._getPathType(pathToCheck);\n        var _strict = strict;\n        if (useNestedStrict &&\n            v &&\n            v.schema &&\n            'strict' in v.schema.options) {\n          _strict = v.schema.options.strict;\n        }\n\n        if (v.pathType === 'undefined') {\n          if (_strict === 'throw') {\n            throw new StrictModeError(pathToCheck);\n          } else if (_strict) {\n            delete obj[key];\n            continue;\n          }\n        }\n\n        // gh-2314\n        // we should be able to set a schema-less field\n        // to an empty object literal\n        hasKeys |= walkUpdatePath(schema, val, op, strict, prefix + key) ||\n          (utils.isObject(val) && Object.keys(val).length === 0);\n      }\n    } else {\n      var checkPath = (key === '$each' || key === '$or' || key === '$and') ?\n        pref : prefix + key;\n      schematype = schema._getSchema(checkPath);\n\n      var pathDetails = schema._getPathType(checkPath);\n      var isStrict = strict;\n      if (useNestedStrict &&\n          pathDetails &&\n          pathDetails.schema &&\n          'strict' in pathDetails.schema.options) {\n        isStrict = pathDetails.schema.options.strict;\n      }\n\n      var skip = isStrict &&\n          !schematype &&\n          !/real|nested/.test(pathDetails.pathType);\n\n      if (skip) {\n        if (isStrict === 'throw') {\n          throw new StrictModeError(prefix + key);\n        } else {\n          delete obj[key];\n        }\n      } else {\n        // gh-1845 temporary fix: ignore $rename. See gh-3027 for tracking\n        // improving this.\n        if (op === '$rename') {\n          hasKeys = true;\n          continue;\n        }\n\n        hasKeys = true;\n        obj[key] = castUpdateVal(schematype, val, op, key);\n      }\n    }\n  }\n  return hasKeys;\n}\n\n/*!\n * These operators should be cast to numbers instead\n * of their path schema type.\n */\n\nvar numberOps = {\n  $pop: 1,\n  $unset: 1,\n  $inc: 1\n};\n\n/*!\n * These operators require casting docs\n * to real Documents for Update operations.\n */\n\nvar castOps = {\n  $push: 1,\n  $pushAll: 1,\n  $addToSet: 1,\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/*!\n * Casts `val` according to `schema` and atomic `op`.\n *\n * @param {SchemaType} schema\n * @param {Object} val\n * @param {String} op - the atomic operator ($pull, $set, etc)\n * @param {String} [$conditional]\n * @api private\n */\n\nfunction castUpdateVal(schema, val, op, $conditional) {\n  if (!schema) {\n    // non-existing schema path\n    return op in numberOps\n        ? Number(val)\n        : val;\n  }\n\n  var cond = schema.caster && op in castOps &&\n      (utils.isObject(val) || Array.isArray(val));\n  if (cond) {\n    // Cast values for ops that add data to MongoDB.\n    // Ensures embedded documents get ObjectIds etc.\n    var tmp = schema.cast(val);\n    if (Array.isArray(val)) {\n      val = tmp;\n    } else if (Array.isArray(tmp)) {\n      val = tmp[0];\n    } else {\n      val = tmp;\n    }\n    return val;\n  }\n\n  if (op in numberOps) {\n    if (op === '$inc') {\n      return schema.castForQuery(val);\n    }\n    return Number(val);\n  }\n  if (op === '$currentDate') {\n    if (typeof val === 'object') {\n      return {$type: val.$type};\n    }\n    return Boolean(val);\n  }\n  if (/^\\$/.test($conditional)) {\n    return schema.castForQuery($conditional, val);\n  }\n\n  return schema.castForQuery(val);\n}\n"]}
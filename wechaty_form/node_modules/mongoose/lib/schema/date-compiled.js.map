{"version":3,"sources":["date.js"],"names":[],"mappings":"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","file":"date-compiled.js","sourcesContent":["/*!\n * Module requirements.\n */\n\nvar MongooseError = require('../error');\nvar utils = require('../utils');\n\nvar SchemaType = require('../schematype');\n\nvar CastError = SchemaType.CastError;\n\n/**\n * Date SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaDate(key, options) {\n  SchemaType.call(this, key, options, 'Date');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaDate.schemaName = 'Date';\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaDate.prototype = Object.create(SchemaType.prototype);\nSchemaDate.prototype.constructor = SchemaDate;\n\n/**\n * Declares a TTL index (rounded to the nearest second) for _Date_ types only.\n *\n * This sets the `expireAfterSeconds` index option available in MongoDB >= 2.1.2.\n * This index type is only compatible with Date types.\n *\n * ####Example:\n *\n *     // expire in 24 hours\n *     new Schema({ createdAt: { type: Date, expires: 60*60*24 }});\n *\n * `expires` utilizes the `ms` module from [guille](https://github.com/guille/) allowing us to use a friendlier syntax:\n *\n * ####Example:\n *\n *     // expire in 24 hours\n *     new Schema({ createdAt: { type: Date, expires: '24h' }});\n *\n *     // expire in 1.5 hours\n *     new Schema({ createdAt: { type: Date, expires: '1.5h' }});\n *\n *     // expire in 7 days\n *     var schema = new Schema({ createdAt: Date });\n *     schema.path('createdAt').expires('7d');\n *\n * @param {Number|String} when\n * @added 3.0.0\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaDate.prototype.expires = function(when) {\n  if (!this._index || this._index.constructor.name !== 'Object') {\n    this._index = {};\n  }\n\n  this._index.expires = when;\n  utils.expires(this._index);\n  return this;\n};\n\n/**\n * Check if the given value satisfies a required validator. To satisfy\n * a required validator, the given value must be an instance of `Date`.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaDate.prototype.checkRequired = function(value) {\n  return value instanceof Date;\n};\n\n/**\n * Sets a minimum date validator.\n *\n * ####Example:\n *\n *     var s = new Schema({ d: { type: Date, min: Date('1970-01-01') })\n *     var M = db.model('M', s)\n *     var m = new M({ d: Date('1969-12-31') })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.d = Date('2014-12-08');\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MIN} token which will be replaced with the invalid value\n *     var min = [Date('1970-01-01'), 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];\n *     var schema = new Schema({ d: { type: Date, min: min })\n *     var M = mongoose.model('M', schema);\n *     var s= new M({ d: Date('1969-12-31') });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `d` (1969-12-31) is before the limit (1970-01-01).\n *     })\n *\n * @param {Date} value minimum date\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_MongooseError-messages\n * @api public\n */\n\nSchemaDate.prototype.min = function(value, message) {\n  if (this.minValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.minValidator;\n    }, this);\n  }\n\n  if (value) {\n    var msg = message || MongooseError.messages.Date.min;\n    msg = msg.replace(/{MIN}/, (value === Date.now ? 'Date.now()' : this.cast(value).toString()));\n    var _this = this;\n    this.validators.push({\n      validator: this.minValidator = function(val) {\n        var min = (value === Date.now ? value() : _this.cast(value));\n        return val === null || val.valueOf() >= min.valueOf();\n      },\n      message: msg,\n      type: 'min',\n      min: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Sets a maximum date validator.\n *\n * ####Example:\n *\n *     var s = new Schema({ d: { type: Date, max: Date('2014-01-01') })\n *     var M = db.model('M', s)\n *     var m = new M({ d: Date('2014-12-08') })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.d = Date('2013-12-31');\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MAX} token which will be replaced with the invalid value\n *     var max = [Date('2014-01-01'), 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];\n *     var schema = new Schema({ d: { type: Date, max: max })\n *     var M = mongoose.model('M', schema);\n *     var s= new M({ d: Date('2014-12-08') });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `d` (2014-12-08) exceeds the limit (2014-01-01).\n *     })\n *\n * @param {Date} maximum date\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_MongooseError-messages\n * @api public\n */\n\nSchemaDate.prototype.max = function(value, message) {\n  if (this.maxValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.maxValidator;\n    }, this);\n  }\n\n  if (value) {\n    var msg = message || MongooseError.messages.Date.max;\n    msg = msg.replace(/{MAX}/, (value === Date.now ? 'Date.now()' : this.cast(value).toString()));\n    var _this = this;\n    this.validators.push({\n      validator: this.maxValidator = function(val) {\n        var max = (value === Date.now ? value() : _this.cast(value));\n        return val === null || val.valueOf() <= max.valueOf();\n      },\n      message: msg,\n      type: 'max',\n      max: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Casts to date\n *\n * @param {Object} value to cast\n * @api private\n */\n\nSchemaDate.prototype.cast = function(value) {\n  // If null or undefined\n  if (value === null || value === void 0 || value === '') {\n    return null;\n  }\n\n  if (value instanceof Date) {\n    if (isNaN(value.valueOf())) {\n      throw new CastError('date', value, this.path);\n    }\n\n    return value;\n  }\n\n  var date;\n\n  if (typeof value === 'boolean') {\n    throw new CastError('date', value, this.path);\n  }\n\n  if (value instanceof Number || typeof value === 'number'\n      || String(value) == Number(value)) {\n    // support for timestamps\n    date = new Date(Number(value));\n  } else if (value.valueOf) {\n    // support for moment.js\n    date = new Date(value.valueOf());\n  }\n\n  if (!isNaN(date.valueOf())) {\n    return date;\n  }\n\n  throw new CastError('date', value, this.path);\n};\n\n/*!\n * Date Query casting.\n *\n * @api private\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nSchemaDate.prototype.$conditionalHandlers =\n    utils.options(SchemaType.prototype.$conditionalHandlers, {\n      $gt: handleSingle,\n      $gte: handleSingle,\n      $lt: handleSingle,\n      $lte: handleSingle\n    });\n\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaDate.prototype.castForQuery = function($conditional, val) {\n  var handler;\n\n  if (arguments.length !== 2) {\n    return this.cast($conditional);\n  }\n\n  handler = this.$conditionalHandlers[$conditional];\n\n  if (!handler) {\n    throw new Error('Can\\'t use ' + $conditional + ' with Date.');\n  }\n\n  return handler.call(this, val);\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaDate;\n"]}
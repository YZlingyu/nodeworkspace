{"version":3,"sources":["queryhelpers.js"],"names":[],"mappings":"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","file":"queryhelpers-compiled.js","sourcesContent":["\n/*!\n * Module dependencies\n */\n\nvar utils = require('./utils');\n\n/*!\n * Prepare a set of path options for query population.\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptions = function preparePopulationOptions(query, options) {\n  var pop = utils.object.vals(query.options.populate);\n\n  // lean options should trickle through all queries\n  if (options.lean) pop.forEach(makeLean);\n\n  return pop;\n};\n\n/*!\n * Prepare a set of path options for query population. This is the MongooseQuery\n * version\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {\n  var pop = utils.object.vals(query._mongooseOptions.populate);\n\n  // lean options should trickle through all queries\n  if (options.lean) pop.forEach(makeLean);\n\n  return pop;\n};\n\n/*!\n * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,\n * it returns an instance of the given model.\n *\n * @param {Model}  model\n * @param {Object} doc\n * @param {Object} fields\n *\n * @return {Model}\n */\nexports.createModel = function createModel(model, doc, fields) {\n  var discriminatorMapping = model.schema\n    ? model.schema.discriminatorMapping\n    : null;\n\n  var key = discriminatorMapping && discriminatorMapping.isRoot\n    ? discriminatorMapping.key\n    : null;\n\n  if (key && doc[key] && model.discriminators && model.discriminators[doc[key]]) {\n    var discriminator = model.discriminators[doc[key]];\n    var _fields = utils.clone(fields);\n    exports.applyPaths(_fields, discriminator.schema);\n    return new model.discriminators[doc[key]](undefined, _fields, true);\n  }\n\n  return new model(undefined, fields, true);\n};\n\n/*!\n * ignore\n */\n\nexports.applyPaths = function applyPaths(fields, schema) {\n  // determine if query is selecting or excluding fields\n\n  var exclude;\n  var keys;\n  var ki;\n\n  if (fields) {\n    keys = Object.keys(fields);\n    ki = keys.length;\n\n    while (ki--) {\n      if (keys[ki][0] === '+') continue;\n      exclude = fields[keys[ki]] === 0;\n      break;\n    }\n  }\n\n  // if selecting, apply default schematype select:true fields\n  // if excluding, apply schematype select:false fields\n\n  var selected = [],\n      excluded = [],\n      seen = [];\n\n  var analyzePath = function(path, type) {\n    if (typeof type.selected !== 'boolean') return;\n\n    var plusPath = '+' + path;\n    if (fields && plusPath in fields) {\n      // forced inclusion\n      delete fields[plusPath];\n\n      // if there are other fields being included, add this one\n      // if no other included fields, leave this out (implied inclusion)\n      if (exclude === false && keys.length > 1 && !~keys.indexOf(path)) {\n        fields[path] = 1;\n      }\n\n      return;\n    }\n\n    // check for parent exclusions\n    var root = path.split('.')[0];\n    if (~excluded.indexOf(root)) return;\n\n    (type.selected ? selected : excluded).push(path);\n  };\n\n  var analyzeSchema = function(schema, prefix) {\n    prefix || (prefix = '');\n\n    // avoid recursion\n    if (~seen.indexOf(schema)) return;\n    seen.push(schema);\n\n    schema.eachPath(function(path, type) {\n      if (prefix) path = prefix + '.' + path;\n\n      analyzePath(path, type);\n\n      // array of subdocs?\n      if (type.schema) {\n        analyzeSchema(type.schema, path);\n      }\n    });\n  };\n\n  analyzeSchema(schema);\n\n  var i;\n  switch (exclude) {\n    case true:\n      for (i = 0; i < excluded.length; ++i) {\n        fields[excluded[i]] = 0;\n      }\n      break;\n    case false:\n      if (schema &&\n          schema.paths['_id'] &&\n          schema.paths['_id'].options &&\n          schema.paths['_id'].options.select === false) {\n        fields._id = 0;\n      }\n      for (i = 0; i < selected.length; ++i) {\n        fields[selected[i]] = 1;\n      }\n      break;\n    case undefined:\n      // user didn't specify fields, implies returning all fields.\n      // only need to apply excluded fields\n      for (i = 0; i < excluded.length; ++i) {\n        fields[excluded[i]] = 0;\n      }\n      break;\n  }\n};\n\n/*!\n * Set each path query option to lean\n *\n * @param {Object} option\n */\n\nfunction makeLean(option) {\n  option.options || (option.options = {});\n  option.options.lean = true;\n}\n"]}
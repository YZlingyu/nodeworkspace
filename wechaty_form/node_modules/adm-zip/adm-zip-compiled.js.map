{"version":3,"sources":["adm-zip.js"],"names":[],"mappings":"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","file":"adm-zip-compiled.js","sourcesContent":["var fs = require(\"fs\"),\r\n    pth = require(\"path\");\r\n\r\nfs.existsSync = fs.existsSync || pth.existsSync;\r\n\r\nvar ZipEntry = require(\"./zipEntry\"),\r\n    ZipFile =  require(\"./zipFile\"),\r\n    Utils = require(\"./util\");\r\n\r\nmodule.exports = function(/*String*/input) {\r\n    var _zip = undefined,\r\n        _filename = \"\";\r\n\r\n    if (input && typeof input === \"string\") { // load zip file\r\n        if (fs.existsSync(input)) {\r\n            _filename = input;\r\n            _zip = new ZipFile(input, Utils.Constants.FILE);\r\n        } else {\r\n           throw Utils.Errors.INVALID_FILENAME;\r\n        }\r\n    } else if(input && Buffer.isBuffer(input)) { // load buffer\r\n        _zip = new ZipFile(input, Utils.Constants.BUFFER);\r\n    } else { // create new zip file\r\n        _zip = new ZipFile(null, Utils.Constants.NONE);\r\n    }\r\n\r\n    function getEntry(/*Object*/entry) {\r\n        if (entry && _zip) {\r\n            var item;\r\n            // If entry was given as a file name\r\n            if (typeof entry === \"string\")\r\n                item = _zip.getEntry(entry);\r\n            // if entry was given as a ZipEntry object\r\n            if (typeof entry === \"object\" && entry.entryName != undefined && entry.header != undefined)\r\n                item =  _zip.getEntry(entry.entryName);\r\n\r\n            if (item) {\r\n                return item;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    return {\r\n        /**\r\n         * Extracts the given entry from the archive and returns the content as a Buffer object\r\n         * @param entry ZipEntry object or String with the full path of the entry\r\n         *\r\n         * @return Buffer or Null in case of error\r\n         */\r\n        readFile : function(/*Object*/entry) {\r\n            var item = getEntry(entry);\r\n            return item && item.getData() || null;\r\n        },\r\n\r\n        /**\r\n         * Asynchronous readFile\r\n         * @param entry ZipEntry object or String with the full path of the entry\r\n         * @param callback\r\n         *\r\n         * @return Buffer or Null in case of error\r\n         */\r\n        readFileAsync : function(/*Object*/entry, /*Function*/callback) {\r\n            var item = getEntry(entry);\r\n            if (item) {\r\n                item.getDataAsync(callback);\r\n            } else {\r\n                callback(null,\"getEntry failed for:\" + entry)\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Extracts the given entry from the archive and returns the content as plain text in the given encoding\r\n         * @param entry ZipEntry object or String with the full path of the entry\r\n         * @param encoding Optional. If no encoding is specified utf8 is used\r\n         *\r\n         * @return String\r\n         */\r\n        readAsText : function(/*Object*/entry, /*String - Optional*/encoding) {\r\n            var item = getEntry(entry);\r\n            if (item) {\r\n                var data = item.getData();\r\n                if (data && data.length) {\r\n                    return data.toString(encoding || \"utf8\");\r\n                }\r\n            }\r\n            return \"\";\r\n        },\r\n\r\n        /**\r\n         * Asynchronous readAsText\r\n         * @param entry ZipEntry object or String with the full path of the entry\r\n         * @param callback\r\n         * @param encoding Optional. If no encoding is specified utf8 is used\r\n         *\r\n         * @return String\r\n         */\r\n        readAsTextAsync : function(/*Object*/entry, /*Function*/callback, /*String - Optional*/encoding) {\r\n            var item = getEntry(entry);\r\n            if (item) {\r\n                item.getDataAsync(function(data) {\r\n                    if (data && data.length) {\r\n                        callback(data.toString(encoding || \"utf8\"));\r\n                    } else {\r\n                        callback(\"\");\r\n                    }\r\n                })\r\n            } else {\r\n                callback(\"\");\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory\r\n         *\r\n         * @param entry\r\n         */\r\n        deleteFile : function(/*Object*/entry) { // @TODO: test deleteFile\r\n            var item = getEntry(entry);\r\n            if (item) {\r\n                _zip.deleteEntry(item.entryName);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Adds a comment to the zip. The zip must be rewritten after adding the comment.\r\n         *\r\n         * @param comment\r\n         */\r\n        addZipComment : function(/*String*/comment) { // @TODO: test addZipComment\r\n            _zip.comment = comment;\r\n        },\r\n\r\n        /**\r\n         * Returns the zip comment\r\n         *\r\n         * @return String\r\n         */\r\n        getZipComment : function() {\r\n            return _zip.comment || '';\r\n        },\r\n\r\n        /**\r\n         * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment\r\n         * The comment cannot exceed 65535 characters in length\r\n         *\r\n         * @param entry\r\n         * @param comment\r\n         */\r\n        addZipEntryComment : function(/*Object*/entry,/*String*/comment) {\r\n            var item = getEntry(entry);\r\n            if (item) {\r\n                item.comment = comment;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Returns the comment of the specified entry\r\n         *\r\n         * @param entry\r\n         * @return String\r\n         */\r\n        getZipEntryComment : function(/*Object*/entry) {\r\n            var item = getEntry(entry);\r\n            if (item) {\r\n                return item.comment || '';\r\n            }\r\n            return ''\r\n        },\r\n\r\n        /**\r\n         * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content\r\n         *\r\n         * @param entry\r\n         * @param content\r\n         */\r\n        updateFile : function(/*Object*/entry, /*Buffer*/content) {\r\n            var item = getEntry(entry);\r\n            if (item) {\r\n                item.setData(content);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Adds a file from the disk to the archive\r\n         *\r\n         * @param localPath\r\n         */\r\n        addLocalFile : function(/*String*/localPath, /*String*/zipPath, /*String*/zipName) {\r\n             if (fs.existsSync(localPath)) {\r\n                if(zipPath){\r\n                    zipPath=zipPath.split(\"\\\\\").join(\"/\");\r\n                    if(zipPath.charAt(zipPath.length - 1) != \"/\"){\r\n                        zipPath += \"/\";\r\n                    }\r\n                }else{\r\n                    zipPath=\"\";\r\n                }\r\n                 var p = localPath.split(\"\\\\\").join(\"/\").split(\"/\").pop();\r\n                \r\n                 if(zipName){\r\n                    this.addFile(zipPath+zipName, fs.readFileSync(localPath), \"\", 0)\r\n                 }else{\r\n                    this.addFile(zipPath+p, fs.readFileSync(localPath), \"\", 0)\r\n                 }\r\n             } else {\r\n                 throw Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath);\r\n             }\r\n        },\r\n\r\n        /**\r\n         * Adds a local directory and all its nested files and directories to the archive\r\n         *\r\n         * @param localPath\r\n         * @param zipPath optional path inside zip\r\n         * @param filter optional RegExp or Function if files match will\r\n         *               be included.\r\n         */\r\n        addLocalFolder : function(/*String*/localPath, /*String*/zipPath, /*RegExp|Function*/filter) {\r\n            if (filter === undefined) {\r\n              filter = function() { return true; };\r\n            } else if (filter instanceof RegExp) {\r\n              filter = function(filter) {\r\n                return function(filename) {\r\n                  return filter.test(filename);\r\n                }\r\n              }(filter);\r\n            }\r\n\r\n            if(zipPath){\r\n                zipPath=zipPath.split(\"\\\\\").join(\"/\");\r\n                if(zipPath.charAt(zipPath.length - 1) != \"/\"){\r\n                    zipPath += \"/\";\r\n                }\r\n            }else{\r\n                zipPath=\"\";\r\n            }\r\n\t\t\tlocalPath = localPath.split(\"\\\\\").join(\"/\"); //windows fix\r\n            localPath = pth.normalize(localPath);\r\n            if (localPath.charAt(localPath.length - 1) != \"/\")\r\n                localPath += \"/\";\r\n\r\n            if (fs.existsSync(localPath)) {\r\n\r\n                var items = Utils.findFiles(localPath),\r\n                    self = this;\r\n\r\n                if (items.length) {\r\n                    items.forEach(function(path) {\r\n\t\t\t\t\t\tvar p = path.split(\"\\\\\").join(\"/\").replace( new RegExp(localPath, 'i'), \"\"); //windows fix\r\n                        if (filter(p)) {\r\n                            if (p.charAt(p.length - 1) !== \"/\") {\r\n                                self.addFile(zipPath+p, fs.readFileSync(path), \"\", 0)\r\n                            } else {\r\n                                self.addFile(zipPath+p, new Buffer(0), \"\", 0)\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            } else {\r\n                throw Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Allows you to create a entry (file or directory) in the zip file.\r\n         * If you want to create a directory the entryName must end in / and a null buffer should be provided.\r\n         * Comment and attributes are optional\r\n         *\r\n         * @param entryName\r\n         * @param content\r\n         * @param comment\r\n         * @param attr\r\n         */\r\n        addFile : function(/*String*/entryName, /*Buffer*/content, /*String*/comment, /*Number*/attr) {\r\n            var entry = new ZipEntry();\r\n            entry.entryName = entryName;\r\n            entry.comment = comment || \"\";\r\n            entry.attr = attr || 438; //0666;\r\n            if (entry.isDirectory && content.length) {\r\n               // throw Utils.Errors.DIRECTORY_CONTENT_ERROR;\r\n            }\r\n            entry.setData(content);\r\n            _zip.setEntry(entry);\r\n        },\r\n\r\n        /**\r\n         * Returns an array of ZipEntry objects representing the files and folders inside the archive\r\n         *\r\n         * @return Array\r\n         */\r\n        getEntries : function() {\r\n            if (_zip) {\r\n               return _zip.entries;\r\n            } else {\r\n                return [];\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Returns a ZipEntry object representing the file or folder specified by ``name``.\r\n         *\r\n         * @param name\r\n         * @return ZipEntry\r\n         */\r\n        getEntry : function(/*String*/name) {\r\n            return getEntry(name);\r\n        },\r\n\r\n        /**\r\n         * Extracts the given entry to the given targetPath\r\n         * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted\r\n         *\r\n         * @param entry ZipEntry object or String with the full path of the entry\r\n         * @param targetPath Target folder where to write the file\r\n         * @param maintainEntryPath If maintainEntryPath is true and the entry is inside a folder, the entry folder\r\n         *                          will be created in targetPath as well. Default is TRUE\r\n         * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\r\n         *                  Default is FALSE\r\n         *\r\n         * @return Boolean\r\n         */\r\n        extractEntryTo : function(/*Object*/entry, /*String*/targetPath, /*Boolean*/maintainEntryPath, /*Boolean*/overwrite) {\r\n            overwrite = overwrite || false;\r\n            maintainEntryPath = typeof maintainEntryPath == \"undefined\" ? true : maintainEntryPath;\r\n\r\n            var item = getEntry(entry);\r\n            if (!item) {\r\n                throw Utils.Errors.NO_ENTRY;\r\n            }\r\n\r\n            var target = pth.resolve(targetPath, maintainEntryPath ? item.entryName : pth.basename(item.entryName));\r\n\r\n            if (item.isDirectory) {\r\n                target = pth.resolve(target, \"..\");\r\n                var children = _zip.getEntryChildren(item);\r\n                children.forEach(function(child) {\r\n                    if (child.isDirectory) return;\r\n                    var content = child.getData();\r\n                    if (!content) {\r\n                        throw Utils.Errors.CANT_EXTRACT_FILE;\r\n                    }\r\n                    Utils.writeFileTo(pth.resolve(targetPath, maintainEntryPath ? child.entryName : child.entryName.substr(item.entryName.length)), content, overwrite);\r\n                });\r\n                return true;\r\n            }\r\n\r\n            var content = item.getData();\r\n            if (!content) throw Utils.Errors.CANT_EXTRACT_FILE;\r\n\r\n            if (fs.existsSync(target) && !overwrite) {\r\n                throw Utils.Errors.CANT_OVERRIDE;\r\n            }\r\n            Utils.writeFileTo(target, content, overwrite);\r\n\r\n            return true;\r\n        },\r\n\r\n        /**\r\n         * Extracts the entire archive to the given location\r\n         *\r\n         * @param targetPath Target location\r\n         * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\r\n         *                  Default is FALSE\r\n         */\r\n        extractAllTo : function(/*String*/targetPath, /*Boolean*/overwrite) {\r\n            overwrite = overwrite || false;\r\n            if (!_zip) {\r\n                throw Utils.Errors.NO_ZIP;\r\n            }\r\n\r\n            _zip.entries.forEach(function(entry) {\r\n                if (entry.isDirectory) {\r\n                    Utils.makeDir(pth.resolve(targetPath, entry.entryName.toString()));\r\n                    return;\r\n                }\r\n                var content = entry.getData();\r\n                if (!content) {\r\n                    throw Utils.Errors.CANT_EXTRACT_FILE + \"2\";\r\n                }\r\n                Utils.writeFileTo(pth.resolve(targetPath, entry.entryName.toString()), content, overwrite);\r\n            })\r\n        },\r\n\r\n        /**\r\n         * Asynchronous extractAllTo\r\n         *\r\n         * @param targetPath Target location\r\n         * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\r\n         *                  Default is FALSE\r\n         * @param callback\r\n         */\r\n        extractAllToAsync : function(/*String*/targetPath, /*Boolean*/overwrite, /*Function*/callback) {\r\n            overwrite = overwrite || false;\r\n            if (!_zip) {\r\n                callback(new Error(Utils.Errors.NO_ZIP));\r\n                return;\r\n            }\r\n\r\n            var entries = _zip.entries;\r\n            var i = entries.length; \r\n            entries.forEach(function(entry) {\r\n                if(i <= 0) return; // Had an error already\r\n\r\n                if (entry.isDirectory) {\r\n                    Utils.makeDir(pth.resolve(targetPath, entry.entryName.toString()));\r\n                    if(--i == 0)\r\n                        callback(undefined);\r\n                    return;\r\n                }\r\n                entry.getDataAsync(function(content) {\r\n                    if(i <= 0) return;\r\n                    if (!content) {\r\n                        i = 0;\r\n                        callback(new Error(Utils.Errors.CANT_EXTRACT_FILE + \"2\"));\r\n                        return;\r\n                    }\r\n                    Utils.writeFileToAsync(pth.resolve(targetPath, entry.entryName.toString()), content, overwrite, function(succ) {\r\n                        if(i <= 0) return;\r\n\r\n                        if(!succ) {\r\n                            i = 0;\r\n                            callback(new Error('Unable to write'));\r\n                            return;\r\n                        }\r\n\r\n                        if(--i == 0)\r\n                            callback(undefined);\r\n                    });\r\n                    \r\n                });\r\n            })\r\n        },\r\n\r\n        /**\r\n         * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip\r\n         *\r\n         * @param targetFileName\r\n         * @param callback\r\n         */\r\n        writeZip : function(/*String*/targetFileName, /*Function*/callback) {\r\n            if (arguments.length == 1) {\r\n                if (typeof targetFileName == \"function\") {\r\n                    callback = targetFileName;\r\n                    targetFileName = \"\";\r\n                }\r\n            }\r\n\r\n            if (!targetFileName && _filename) {\r\n                targetFileName = _filename;\r\n            }\r\n            if (!targetFileName) return;\r\n\r\n            var zipData = _zip.compressToBuffer();\r\n            if (zipData) {\r\n                var ok = Utils.writeFileTo(targetFileName, zipData, true);\r\n                if (typeof callback == 'function') callback(!ok? new Error(\"failed\"): null, \"\");\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Returns the content of the entire zip file as a Buffer object\r\n         *\r\n         * @return Buffer\r\n         */\r\n        toBuffer : function(/*Function*/onSuccess,/*Function*/onFail,/*Function*/onItemStart,/*Function*/onItemEnd) {\r\n            this.valueOf = 2;\r\n            if (typeof onSuccess == \"function\") {\r\n                _zip.toAsyncBuffer(onSuccess,onFail,onItemStart,onItemEnd);\r\n                return null;\r\n            }\r\n            return _zip.compressToBuffer()\r\n        }\r\n    }\r\n};\r\n"]}
{"version":3,"sources":["zipFile.js"],"names":[],"mappings":"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","file":"zipFile-compiled.js","sourcesContent":["var ZipEntry = require(\"./zipEntry\"),\r\n    Headers = require(\"./headers\"),\r\n    Utils = require(\"./util\");\r\n\r\nmodule.exports = function(/*String|Buffer*/input, /*Number*/inputType) {\r\n    var entryList = [],\r\n        entryTable = {},\r\n        _comment = new Buffer(0),\r\n        filename = \"\",\r\n        fs = require(\"fs\"),\r\n        inBuffer = null,\r\n        mainHeader = new Headers.MainHeader();\r\n\r\n    if (inputType == Utils.Constants.FILE) {\r\n        // is a filename\r\n        filename = input;\r\n        inBuffer = fs.readFileSync(filename);\r\n        readMainHeader();\r\n    } else if (inputType == Utils.Constants.BUFFER) {\r\n        // is a memory buffer\r\n        inBuffer = input;\r\n        readMainHeader();\r\n    } else {\r\n        // none. is a new file\r\n    }\r\n\r\n    function readEntries() {\r\n        entryTable = {};\r\n        entryList = new Array(mainHeader.diskEntries);  // total number of entries\r\n        var index = mainHeader.offset;  // offset of first CEN header\r\n        for(var i = 0; i < entryList.length; i++) {\r\n\r\n            var tmp = index,\r\n                entry = new ZipEntry(inBuffer);\r\n            entry.header = inBuffer.slice(tmp, tmp += Utils.Constants.CENHDR);\r\n\r\n            entry.entryName = inBuffer.slice(tmp, tmp += entry.header.fileNameLength);\r\n\r\n            if (entry.header.extraLength) {\r\n                entry.extra = inBuffer.slice(tmp, tmp += entry.header.extraLength);\r\n            }\r\n\r\n            if (entry.header.commentLength)\r\n                entry.comment = inBuffer.slice(tmp, tmp + entry.header.commentLength);\r\n\r\n            index += entry.header.entryHeaderSize;\r\n\r\n            entryList[i] = entry;\r\n            entryTable[entry.entryName] = entry;\r\n        }\r\n    }\r\n\r\n    function readMainHeader() {\r\n        var i = inBuffer.length - Utils.Constants.ENDHDR, // END header size\r\n            n = Math.max(0, i - 0xFFFF), // 0xFFFF is the max zip file comment length\r\n            endOffset = -1; // Start offset of the END header\r\n\r\n        for (i; i >= n; i--) {\r\n            if (inBuffer[i] != 0x50) continue; // quick check that the byte is 'P'\r\n            if (inBuffer.readUInt32LE(i) == Utils.Constants.ENDSIG) { // \"PK\\005\\006\"\r\n                endOffset = i;\r\n                break;\r\n            }\r\n        }\r\n        if (!~endOffset)\r\n            throw Utils.Errors.INVALID_FORMAT;\r\n\r\n        mainHeader.loadFromBinary(inBuffer.slice(endOffset, endOffset + Utils.Constants.ENDHDR));\r\n        if (mainHeader.commentLength) {\r\n            _comment = inBuffer.slice(endOffset + Utils.Constants.ENDHDR);\r\n        }\r\n        readEntries();\r\n    }\r\n\r\n    return {\r\n        /**\r\n         * Returns an array of ZipEntry objects existent in the current opened archive\r\n         * @return Array\r\n         */\r\n        get entries () {\r\n            return entryList;\r\n        },\r\n\r\n        /**\r\n         * Archive comment\r\n         * @return {String}\r\n         */\r\n        get comment () { return _comment.toString(); },\r\n        set comment(val) {\r\n            mainHeader.commentLength = val.length;\r\n            _comment = val;\r\n        },\r\n\r\n        /**\r\n         * Returns a reference to the entry with the given name or null if entry is inexistent\r\n         *\r\n         * @param entryName\r\n         * @return ZipEntry\r\n         */\r\n        getEntry : function(/*String*/entryName) {\r\n            return entryTable[entryName] || null;\r\n        },\r\n\r\n        /**\r\n         * Adds the given entry to the entry list\r\n         *\r\n         * @param entry\r\n         */\r\n        setEntry : function(/*ZipEntry*/entry) {\r\n            entryList.push(entry);\r\n            entryTable[entry.entryName] = entry;\r\n            mainHeader.totalEntries = entryList.length;\r\n        },\r\n\r\n        /**\r\n         * Removes the entry with the given name from the entry list.\r\n         *\r\n         * If the entry is a directory, then all nested files and directories will be removed\r\n         * @param entryName\r\n         */\r\n        deleteEntry : function(/*String*/entryName) {\r\n            var entry = entryTable[entryName];\r\n            if (entry && entry.isDirectory) {\r\n                var _self = this;\r\n                this.getEntryChildren(entry).forEach(function(child) {\r\n                    if (child.entryName != entryName) {\r\n                        _self.deleteEntry(child.entryName)\r\n                    }\r\n                })\r\n            }\r\n            entryList.splice(entryList.indexOf(entry), 1);\r\n            delete(entryTable[entryName]);\r\n            mainHeader.totalEntries = entryList.length;\r\n        },\r\n\r\n        /**\r\n         *  Iterates and returns all nested files and directories of the given entry\r\n         *\r\n         * @param entry\r\n         * @return Array\r\n         */\r\n        getEntryChildren : function(/*ZipEntry*/entry) {\r\n            if (entry.isDirectory) {\r\n                var list = [],\r\n                    name = entry.entryName,\r\n                    len = name.length;\r\n\r\n                entryList.forEach(function(zipEntry) {\r\n                    if (zipEntry.entryName.substr(0, len) == name) {\r\n                        list.push(zipEntry);\r\n                    }\r\n                });\r\n                return list;\r\n            }\r\n            return []\r\n        },\r\n\r\n        /**\r\n         * Returns the zip file\r\n         *\r\n         * @return Buffer\r\n         */\r\n        compressToBuffer : function() {\r\n            if (entryList.length > 1) {\r\n                entryList.sort(function(a, b) {\r\n                    var nameA = a.entryName.toLowerCase();\r\n                    var nameB = b.entryName.toLowerCase();\r\n                    if (nameA < nameB) {return -1}\r\n                    if (nameA > nameB) {return 1}\r\n                    return 0;\r\n                });\r\n            }\r\n\r\n            var totalSize = 0,\r\n                dataBlock = [],\r\n                entryHeaders = [],\r\n                dindex = 0;\r\n\r\n            mainHeader.size = 0;\r\n            mainHeader.offset = 0;\r\n\r\n            entryList.forEach(function(entry) {\r\n                entry.header.offset = dindex;\r\n\r\n                // compress data and set local and entry header accordingly. Reason why is called first\r\n                var compressedData = entry.getCompressedData();\r\n                // data header\r\n                var dataHeader = entry.header.dataHeaderToBinary();\r\n                var postHeader = new Buffer(entry.entryName + entry.extra.toString());\r\n                var dataLength = dataHeader.length + postHeader.length + compressedData.length;\r\n\r\n                dindex += dataLength;\r\n\r\n                dataBlock.push(dataHeader);\r\n                dataBlock.push(postHeader);\r\n                dataBlock.push(compressedData);\r\n\r\n                var entryHeader = entry.packHeader();\r\n                entryHeaders.push(entryHeader);\r\n                mainHeader.size += entryHeader.length;\r\n                totalSize += (dataLength + entryHeader.length);\r\n            });\r\n\r\n            totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length\r\n            // point to end of data and begining of central directory first record\r\n            mainHeader.offset = dindex;\r\n\r\n            dindex = 0;\r\n            var outBuffer = new Buffer(totalSize);\r\n            dataBlock.forEach(function(content) {\r\n                content.copy(outBuffer, dindex); // write data blocks\r\n                dindex += content.length;\r\n            });\r\n            entryHeaders.forEach(function(content) {\r\n                content.copy(outBuffer, dindex); // write central directory entries\r\n                dindex += content.length;\r\n            });\r\n\r\n            var mh = mainHeader.toBinary();\r\n            if (_comment) {\r\n                _comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment\r\n            }\r\n\r\n            mh.copy(outBuffer, dindex); // write main header\r\n\r\n            return outBuffer\r\n        },\r\n\r\n        toAsyncBuffer : function(/*Function*/onSuccess,/*Function*/onFail,/*Function*/onItemStart,/*Function*/onItemEnd) {\r\n            if (entryList.length > 1) {\r\n                entryList.sort(function(a, b) {\r\n                    var nameA = a.entryName.toLowerCase();\r\n                    var nameB = b.entryName.toLowerCase();\r\n                    if (nameA > nameB) {return -1}\r\n                    if (nameA < nameB) {return 1}\r\n                    return 0;\r\n                });\r\n            }\r\n\r\n            var totalSize = 0,\r\n                dataBlock = [],\r\n                entryHeaders = [],\r\n                dindex = 0;\r\n\r\n            mainHeader.size = 0;\r\n            mainHeader.offset = 0;\r\n\r\n            var compress=function(entryList){\r\n                var self=arguments.callee;\r\n                var entry;\r\n                if(entryList.length){\r\n                    var entry=entryList.pop();\r\n                    var name=entry.entryName + entry.extra.toString();\r\n                    if(onItemStart)onItemStart(name);\r\n                    entry.getCompressedDataAsync(function(compressedData){\r\n                        if(onItemEnd)onItemEnd(name);\r\n\r\n                        entry.header.offset = dindex;\r\n                        // data header\r\n                        var dataHeader = entry.header.dataHeaderToBinary();\r\n                        var postHeader = new Buffer(name);\r\n                        var dataLength = dataHeader.length + postHeader.length + compressedData.length;\r\n\r\n                        dindex += dataLength;\r\n\r\n                        dataBlock.push(dataHeader);\r\n                        dataBlock.push(postHeader);\r\n                        dataBlock.push(compressedData);\r\n\r\n                        var entryHeader = entry.packHeader();\r\n                        entryHeaders.push(entryHeader);\r\n                        mainHeader.size += entryHeader.length;\r\n                        totalSize += (dataLength + entryHeader.length);\r\n\r\n                        if(entryList.length){\r\n                            self(entryList);\r\n                        }else{\r\n\r\n\r\n                            totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length\r\n                            // point to end of data and begining of central directory first record\r\n                            mainHeader.offset = dindex;\r\n\r\n                            dindex = 0;\r\n                            var outBuffer = new Buffer(totalSize);\r\n                            dataBlock.forEach(function(content) {\r\n                                content.copy(outBuffer, dindex); // write data blocks\r\n                                dindex += content.length;\r\n                            });\r\n                            entryHeaders.forEach(function(content) {\r\n                                content.copy(outBuffer, dindex); // write central directory entries\r\n                                dindex += content.length;\r\n                            });\r\n\r\n                            var mh = mainHeader.toBinary();\r\n                            if (_comment) {\r\n                                _comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment\r\n                            }\r\n\r\n                            mh.copy(outBuffer, dindex); // write main header\r\n\r\n                            onSuccess(outBuffer);\r\n                        }\r\n                    });\r\n                }\r\n            };\r\n\r\n            compress(entryList);\r\n        }\r\n    }\r\n};\r\n"]}
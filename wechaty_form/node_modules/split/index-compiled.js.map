{"version":3,"sources":["index.js"],"names":[],"mappings":"AAAA;;AAEA;AACA;AACA;;;AAGA,IAAI,UAAU,QAAQ,SAAR,CAAd;AACA,IAAI,UAAU,QAAQ,gBAAR,EAA0B,aAAxC;;AAEA,OAAO,OAAP,GAAiB,KAAjB;;AAEA;;AAEA,SAAS,KAAT,CAAgB,OAAhB,EAAyB,MAAzB,EAAiC,OAAjC,EAA0C;AACxC,MAAI,UAAU,IAAI,OAAJ,EAAd;AACA,MAAI,QAAQ,EAAZ;AACA,MAAI,YAAY,WAAW,QAAQ,SAAnC;AACA,MAAG,eAAe,OAAO,OAAzB,EACE,SAAS,OAAT,EAAkB,UAAU,IAA5B;AACF,MAAI,CAAC,OAAL,EACE,UAAU,OAAV;;AAEF,WAAS,IAAT,CAAc,MAAd,EAAsB,KAAtB,EAA6B;AAC3B,QAAG,MAAH,EAAW;AACT,UAAI;AACF,gBAAQ,OAAO,KAAP,CAAR;AACD,OAFD,CAGA,OAAO,GAAP,EAAY;AACV,eAAO,OAAO,IAAP,CAAY,OAAZ,EAAqB,GAArB,CAAP;AACD;AACD,UAAG,gBAAgB,OAAO,KAA1B,EACE,OAAO,KAAP,CAAa,KAAb;AACH,KATD,MAWE,OAAO,KAAP,CAAa,KAAb;AACH;;AAED,WAAS,IAAT,CAAe,MAAf,EAAuB,MAAvB,EAA+B;AAC7B,QAAI,SAAS,CAAC,CAAC,SAAS,IAAT,GAAgB,KAAhB,GAAwB,EAAzB,IAA+B,MAAhC,EAAwC,KAAxC,CAA8C,OAA9C,CAAb;AACA,YAAQ,OAAO,GAAP,EAAR;;AAEA,QAAI,aAAa,MAAM,MAAN,GAAe,SAAhC,EACE,OAAO,IAAP,CAAY,OAAZ,EAAqB,IAAI,KAAJ,CAAU,wBAAV,CAArB;;AAEF,SAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,OAAO,MAA3B,EAAmC,GAAnC,EAAwC;AACtC,UAAI,QAAQ,OAAO,CAAP,CAAZ;AACA,WAAK,MAAL,EAAa,KAAb;AACD;AACF;;AAED,SAAO,QAAQ,UAAU,CAAV,EAAa;AAC1B,SAAK,IAAL,EAAW,QAAQ,KAAR,CAAc,CAAd,CAAX;AACD,GAFM,EAGP,YAAY;AACV,QAAG,QAAQ,GAAX,EACE,KAAK,IAAL,EAAW,QAAQ,GAAR,EAAX;AACF,QAAG,SAAS,IAAZ,EACE,KAAK,IAAL,EAAW,KAAX;AACF,SAAK,KAAL,CAAW,IAAX;AACD,GATM,CAAP;AAUD","file":"index-compiled.js","sourcesContent":["//filter will reemit the data if cb(err,pass) pass is truthy\n\n// reduce is more tricky\n// maybe we want to group the reductions or emit progress updates occasionally\n// the most basic reduce just emits one 'data' event after it has recieved 'end'\n\n\nvar through = require('through')\nvar Decoder = require('string_decoder').StringDecoder\n\nmodule.exports = split\n\n//TODO pass in a function to map across the lines.\n\nfunction split (matcher, mapper, options) {\n  var decoder = new Decoder()\n  var soFar = ''\n  var maxLength = options && options.maxLength;\n  if('function' === typeof matcher)\n    mapper = matcher, matcher = null\n  if (!matcher)\n    matcher = /\\r?\\n/\n\n  function emit(stream, piece) {\n    if(mapper) {\n      try {\n        piece = mapper(piece)\n      }\n      catch (err) {\n        return stream.emit('error', err)\n      }\n      if('undefined' !== typeof piece)\n        stream.queue(piece)\n    }\n    else\n      stream.queue(piece)\n  }\n\n  function next (stream, buffer) {\n    var pieces = ((soFar != null ? soFar : '') + buffer).split(matcher)\n    soFar = pieces.pop()\n\n    if (maxLength && soFar.length > maxLength)\n      stream.emit('error', new Error('maximum buffer reached'))\n\n    for (var i = 0; i < pieces.length; i++) {\n      var piece = pieces[i]\n      emit(stream, piece)\n    }\n  }\n\n  return through(function (b) {\n    next(this, decoder.write(b))\n  },\n  function () {\n    if(decoder.end)\n      next(this, decoder.end())\n    if(soFar != null)\n      emit(this, soFar)\n    this.queue(null)\n  })\n}\n\n"]}
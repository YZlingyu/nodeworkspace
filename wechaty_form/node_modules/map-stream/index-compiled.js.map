{"version":3,"sources":["index.js"],"names":[],"mappings":"AAAA;;AAEA;AACA;AACA;;;AAGA,IAAI,SAAS,QAAQ,QAAR,EAAkB,MAA/B;;AAGA;AACA;AACA;;AAEA,OAAO,OAAP,GAAiB,UAAU,MAAV,EAAkB,IAAlB,EAAwB;;AAEvC,MAAI,SAAS,IAAI,MAAJ,EAAb;AAAA,MACI,OAAO,IADX;AAAA,MAEI,SAAS,CAFb;AAAA,MAGI,UAAU,CAHd;AAAA,MAII,QAAQ,KAJZ;AAAA,MAKI,SAAS,KALb;AAAA,MAMI,YAAY,KANhB;AAAA,MAOI,cAAc,CAPlB;AAAA,MAQI,SAAS,KARb;;AAUA,OAAK,IAAL,GAAY,QAAQ,EAApB;AACA,MAAI,iBAAiB,KAAK,IAAL,CAAU,QAAV,GAAqB,SAArB,GAAiC,OAAtD;;AAEA;AACA;AACA,MAAI,aAAa,EAAjB;;AAEA,SAAO,QAAP,GAAkB,IAAlB;AACA,SAAO,QAAP,GAAkB,IAAlB;;AAEA,WAAS,SAAT,CAAoB,IAApB,EAA0B,MAA1B,EAAkC;AAChC,QAAI,cAAc,cAAc,CAAhC;;AAEA,QAAI,WAAW,WAAf,EAA4B;AAC1B;AACA,UAAI,SAAS,SAAb,EAAwB;AACtB,eAAO,IAAP,CAAY,KAAZ,CAAkB,MAAlB,EAA0B,CAAC,MAAD,EAAS,IAAT,CAA1B;AACD;AACD;AACA;AACD,KAPD,MAOO;AACL;AACA,iBAAW,MAAX,IAAqB,IAArB;AACD;;AAED;AACA,QAAI,WAAW,cAAX,CAA0B,WAA1B,CAAJ,EAA4C;AAC1C,UAAI,cAAc,WAAW,WAAX,CAAlB;AACA,aAAO,WAAW,WAAX,CAAP;AACA,aAAO,UAAU,WAAV,EAAuB,WAAvB,CAAP;AACD;;AAED;AACA,QAAG,WAAW,OAAd,EAAuB;AACrB,UAAG,MAAH,EAAW,SAAS,KAAT,EAAgB,OAAO,IAAP,CAAY,OAAZ,CAAhB,CADU,CAC2B;AAChD,UAAG,KAAH,EAAU;AACX;AACF;;AAED,WAAS,IAAT,CAAe,GAAf,EAAoB,IAApB,EAA0B,MAA1B,EAAkC;AAChC,QAAG,SAAH,EAAc;AACd,aAAS,IAAT;;AAEA,QAAI,CAAC,GAAD,IAAQ,KAAK,IAAL,CAAU,QAAtB,EAAgC;AAC9B,gBAAU,IAAV,EAAgB,MAAhB;AACD;;AAED,QAAI,GAAJ,EAAS;AACP,aAAO,IAAP,CAAY,KAAZ,CAAkB,MAAlB,EAA0B,CAAE,cAAF,EAAkB,GAAlB,CAA1B;AACD;;AAED,aAAS,KAAT;AACD;;AAED;AACA;AACA,WAAS,aAAT,CAAwB,KAAxB,EAA+B,MAA/B,EAAuC,QAAvC,EAAiD;AAC/C,WAAO,OAAO,IAAP,CAAY,IAAZ,EAAkB,KAAlB,EAAyB,UAAS,GAAT,EAAc,IAAd,EAAmB;AACjD,eAAS,GAAT,EAAc,IAAd,EAAoB,MAApB;AACD,KAFM,CAAP;AAGD;;AAED,SAAO,KAAP,GAAe,UAAU,IAAV,EAAgB;AAC7B,QAAG,KAAH,EAAU,MAAM,IAAI,KAAJ,CAAU,4BAAV,CAAN;AACV,aAAS,KAAT;AACA;;AAEA,QAAI;AACF;AACA,UAAI,UAAU,cAAc,IAAd,EAAoB,MAApB,EAA4B,IAA5B,CAAd;AACA,eAAU,YAAY,KAAtB;AACA,aAAO,CAAC,MAAR;AACD,KALD,CAKE,OAAO,GAAP,EAAY;AACZ;AACA;AACA,UAAG,MAAH,EACE,MAAM,GAAN;AACF,WAAK,GAAL;AACA,aAAO,CAAC,MAAR;AACD;AACF,GAlBD;;AAoBA,WAAS,GAAT,CAAc,IAAd,EAAoB;AAClB;AACA,YAAQ,IAAR,CAFkB,CAEL;AACb,WAAO,QAAP,GAAkB,KAAlB;AACA,QAAG,SAAS,SAAZ,EAAuB;AACrB,aAAO,UAAU,IAAV,EAAgB,MAAhB,CAAP;AACD,KAFD,MAEO,IAAI,UAAU,OAAd,EAAuB;AAAE;AAC9B,aAAO,QAAP,GAAkB,KAAlB,EAAyB,OAAO,IAAP,CAAY,KAAZ,CAAzB,EAA6C,OAAO,OAAP,EAA7C;AACD;AACF;;AAED,SAAO,GAAP,GAAa,UAAU,IAAV,EAAgB;AAC3B,QAAG,KAAH,EAAU;AACV;AACD,GAHD;;AAKA,SAAO,OAAP,GAAiB,YAAY;AAC3B,YAAQ,YAAY,IAApB;AACA,WAAO,QAAP,GAAkB,OAAO,QAAP,GAAkB,SAAS,KAA7C;AACA,YAAQ,QAAR,CAAiB,YAAY;AAC3B,aAAO,IAAP,CAAY,OAAZ;AACD,KAFD;AAGD,GAND;AAOA,SAAO,KAAP,GAAe,YAAY;AACzB,aAAS,IAAT;AACD,GAFD;;AAIA,SAAO,MAAP,GAAgB,YAAY;AAC1B,aAAS,KAAT;AACD,GAFD;;AAIA,SAAO,MAAP;AACD,CA9HD","file":"index-compiled.js","sourcesContent":["//filter will reemit the data if cb(err,pass) pass is truthy\n\n// reduce is more tricky\n// maybe we want to group the reductions or emit progress updates occasionally\n// the most basic reduce just emits one 'data' event after it has recieved 'end'\n\n\nvar Stream = require('stream').Stream\n\n\n//create an event stream and apply function to each .write\n//emitting each response as data\n//unless it's an empty callback\n\nmodule.exports = function (mapper, opts) {\n\n  var stream = new Stream()\n    , self = this\n    , inputs = 0\n    , outputs = 0\n    , ended = false\n    , paused = false\n    , destroyed = false\n    , lastWritten = 0\n    , inNext = false\n\n  this.opts = opts || {};\n  var errorEventName = this.opts.failures ? 'failure' : 'error';\n\n  // Items that are not ready to be written yet (because they would come out of\n  // order) get stuck in a queue for later.\n  var writeQueue = {}\n\n  stream.writable = true\n  stream.readable = true\n\n  function queueData (data, number) {\n    var nextToWrite = lastWritten + 1\n\n    if (number === nextToWrite) {\n      // If it's next, and its not undefined write it\n      if (data !== undefined) {\n        stream.emit.apply(stream, ['data', data])\n      }\n      lastWritten ++\n      nextToWrite ++\n    } else {\n      // Otherwise queue it for later.\n      writeQueue[number] = data\n    }\n\n    // If the next value is in the queue, write it\n    if (writeQueue.hasOwnProperty(nextToWrite)) {\n      var dataToWrite = writeQueue[nextToWrite]\n      delete writeQueue[nextToWrite]\n      return queueData(dataToWrite, nextToWrite)\n    }\n\n    outputs ++\n    if(inputs === outputs) {\n      if(paused) paused = false, stream.emit('drain') //written all the incoming events\n      if(ended) end()\n    }\n  }\n\n  function next (err, data, number) {\n    if(destroyed) return\n    inNext = true\n\n    if (!err || self.opts.failures) {\n      queueData(data, number)\n    }\n\n    if (err) {\n      stream.emit.apply(stream, [ errorEventName, err ]);\n    }\n\n    inNext = false;\n  }\n\n  // Wrap the mapper function by calling its callback with the order number of\n  // the item in the stream.\n  function wrappedMapper (input, number, callback) {\n    return mapper.call(null, input, function(err, data){\n      callback(err, data, number)\n    })\n  }\n\n  stream.write = function (data) {\n    if(ended) throw new Error('map stream is not writable')\n    inNext = false\n    inputs ++\n\n    try {\n      //catch sync errors and handle them like async errors\n      var written = wrappedMapper(data, inputs, next)\n      paused = (written === false)\n      return !paused\n    } catch (err) {\n      //if the callback has been called syncronously, and the error\n      //has occured in an listener, throw it again.\n      if(inNext)\n        throw err\n      next(err)\n      return !paused\n    }\n  }\n\n  function end (data) {\n    //if end was called with args, write it, \n    ended = true //write will emit 'end' if ended is true\n    stream.writable = false\n    if(data !== undefined) {\n      return queueData(data, inputs)\n    } else if (inputs == outputs) { //wait for processing \n      stream.readable = false, stream.emit('end'), stream.destroy() \n    }\n  }\n\n  stream.end = function (data) {\n    if(ended) return\n    end()\n  }\n\n  stream.destroy = function () {\n    ended = destroyed = true\n    stream.writable = stream.readable = paused = false\n    process.nextTick(function () {\n      stream.emit('close')\n    })\n  }\n  stream.pause = function () {\n    paused = true\n  }\n\n  stream.resume = function () {\n    paused = false\n  }\n\n  return stream\n}\n\n\n\n\n"]}
{"version":3,"sources":["index.js"],"names":[],"mappings":";AACA;;AAEA,IAAI,SAAS,QAAQ,QAAR,CAAb;;AAEA;AACA;AACA;AACA;AACA;;AAEA,OAAO,OAAP,GACA,SAAS,IAAT,CAAe,MAAf,EAAuB;AACrB,MAAG,MAAM,OAAN,CAAc,MAAd,CAAH,EAA0B;AAC1B,QAAI,eAAe,CAAnB;AAAA,QAAsB,aAAa,OAAO,MAA1C;AACE,WAAO,KAAM,UAAU,CAAV,EAAa;AACxB,UAAG,eAAe,UAAlB,EACE,KAAK,IAAL,CAAU,MAAV,EAAkB,OAAO,cAAP,CAAlB,EADF,KAGE,KAAK,IAAL,CAAU,KAAV;AACF,aAAO,IAAP;AACD,KANM,CAAP;AAOD;AACD,MAAI,IAAI,IAAI,MAAJ,EAAR;AAAA,MAAsB,IAAI,CAA1B;AACA,IAAE,KAAF,GAAU,KAAV;AACA,IAAE,OAAF,GAAY,KAAZ;AACA,IAAE,QAAF,GAAa,IAAb;AACA,IAAE,QAAF,GAAa,KAAb;AACA,IAAE,MAAF,GAAW,KAAX;AACA,IAAE,KAAF,GAAU,KAAV;AACA,IAAE,KAAF,GAAU,YAAY;AACpB,MAAE,OAAF,GAAY,IAAZ;AACA,MAAE,MAAF,GAAW,IAAX;AACD,GAHD;AAIA,WAAS,IAAT,GAAiB;AACf,MAAE,OAAF,GAAY,IAAZ;AACA,QAAG,EAAE,KAAL,EAAY;AACZ,WAAM,CAAC,EAAE,KAAH,IAAY,CAAC,EAAE,MAAf,IAAyB,OAAO,IAAP,CAAY,CAAZ,EAAe,GAAf,EAAoB,YAAY;AAC7D,UAAG,CAAC,EAAE,KAAH,IAAY,CAAC,EAAE,MAAlB,EACI,QAAQ,QAAR,CAAiB,IAAjB;AACL,KAH8B,CAA/B,CAIE;AACH;AACD,IAAE,MAAF,GAAW,YAAY;AACrB,MAAE,OAAF,GAAY,IAAZ;AACA,MAAE,MAAF,GAAW,KAAX;AACA;AACD,GAJD;AAKA,IAAE,EAAF,CAAK,KAAL,EAAY,YAAY;AACtB,MAAE,KAAF,GAAU,IAAV;AACA,MAAE,QAAF,GAAa,KAAb;AACA,YAAQ,QAAR,CAAiB,EAAE,OAAnB;AACD,GAJD;AAKA,IAAE,OAAF,GAAY,YAAY;AACtB,MAAE,KAAF,GAAU,IAAV;AACA,MAAE,IAAF,CAAO,OAAP;AACD,GAHD;AAIA;;;;;;AAMA,UAAQ,QAAR,CAAiB,YAAY;AAC3B,QAAG,CAAC,EAAE,OAAN,EAAe,EAAE,MAAF;AAChB,GAFD;AAGA,SAAO,CAAP;AACD,CAxDD","file":"index-compiled.js","sourcesContent":["\n'use strict';\n\nvar Stream = require('stream')\n\n// from\n//\n// a stream that reads from an source.\n// source may be an array, or a function.\n// from handles pause behaviour for you.\n\nmodule.exports =\nfunction from (source) {\n  if(Array.isArray(source)) {\n\t\tvar source_index = 0, source_len = source.length;\n    return from (function (i) {\n      if(source_index < source_len)\n        this.emit('data', source[source_index++])\n      else\n        this.emit('end')\n      return true\n    })\n  }\n  var s = new Stream(), i = 0\n  s.ended = false\n  s.started = false\n  s.readable = true\n  s.writable = false\n  s.paused = false\n  s.ended = false\n  s.pause = function () {\n    s.started = true\n    s.paused = true\n  }\n  function next () {\n    s.started = true\n    if(s.ended) return\n    while(!s.ended && !s.paused && source.call(s, i++, function () {\n      if(!s.ended && !s.paused)\n          process.nextTick(next);\n    }))\n      ;\n  }\n  s.resume = function () {\n    s.started = true\n    s.paused = false\n    next()\n  }\n  s.on('end', function () {\n    s.ended = true\n    s.readable = false\n    process.nextTick(s.destroy)\n  })\n  s.destroy = function () {\n    s.ended = true\n    s.emit('close') \n  }\n  /*\n    by default, the stream will start emitting at nextTick\n    if you want, you can pause it, after pipeing.\n    you can also resume before next tick, and that will also\n    work.\n  */\n  process.nextTick(function () {\n    if(!s.started) s.resume()\n  })\n  return s\n}\n"]}
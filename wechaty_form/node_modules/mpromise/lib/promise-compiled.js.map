{"version":3,"sources":["promise.js"],"names":[],"mappings":"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","file":"promise-compiled.js","sourcesContent":["'use strict';\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nfunction toArray(arr, start, end) {\n  return Array.prototype.slice.call(arr, start, end)\n}\nfunction strongUnshift(x, arrLike) {\n  var arr = toArray(arrLike);\n  arr.unshift(x);\n  return arr;\n}\n\n\n/**\n * MPromise constructor.\n *\n * _NOTE: The success and failure event names can be overridden by setting `Promise.SUCCESS` and `Promise.FAILURE` respectively._\n *\n * @param {Function} back a function that accepts `fn(err, ...){}` as signature\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `reject`: Emits when the promise is rejected (event name may be overridden)\n * @event `fulfill`: Emits when the promise is fulfilled (event name may be overridden)\n * @api public\n */\nfunction Promise(back) {\n  this.emitter = new EventEmitter();\n  this.emitted = {};\n  this.ended = false;\n  if ('function' == typeof back) {\n    this.ended = true;\n    this.onResolve(back);\n  }\n}\n\n\n/*\n * Module exports.\n */\nmodule.exports = Promise;\n\n\n/*!\n * event names\n */\nPromise.SUCCESS = 'fulfill';\nPromise.FAILURE = 'reject';\n\n\n/**\n * Adds `listener` to the `event`.\n *\n * If `event` is either the success or failure event and the event has already been emitted, the`listener` is called immediately and passed the results of the original emitted event.\n *\n * @param {String} event\n * @param {Function} callback\n * @return {MPromise} this\n * @api private\n */\nPromise.prototype.on = function (event, callback) {\n  if (this.emitted[event])\n    callback.apply(undefined, this.emitted[event]);\n  else\n    this.emitter.on(event, callback);\n\n  return this;\n};\n\n\n/**\n * Keeps track of emitted events to run them on `on`.\n *\n * @api private\n */\nPromise.prototype.safeEmit = function (event) {\n  // ensures a promise can't be fulfill() or reject() more than once\n  if (event == Promise.SUCCESS || event == Promise.FAILURE) {\n    if (this.emitted[Promise.SUCCESS] || this.emitted[Promise.FAILURE]) {\n      return this;\n    }\n    this.emitted[event] = toArray(arguments, 1);\n  }\n\n  this.emitter.emit.apply(this.emitter, arguments);\n  return this;\n};\n\n\n/**\n * @api private\n */\nPromise.prototype.hasRejectListeners = function () {\n  return EventEmitter.listenerCount(this.emitter, Promise.FAILURE) > 0;\n};\n\n\n/**\n * Fulfills this promise with passed arguments.\n *\n * If this promise has already been fulfilled or rejected, no action is taken.\n *\n * @api public\n */\nPromise.prototype.fulfill = function () {\n  return this.safeEmit.apply(this, strongUnshift(Promise.SUCCESS, arguments));\n};\n\n\n/**\n * Rejects this promise with `reason`.\n *\n * If this promise has already been fulfilled or rejected, no action is taken.\n *\n * @api public\n * @param {Object|String} reason\n * @return {MPromise} this\n */\nPromise.prototype.reject = function (reason) {\n  if (this.ended && !this.hasRejectListeners())\n    throw reason;\n  return this.safeEmit(Promise.FAILURE, reason);\n};\n\n\n/**\n * Resolves this promise to a rejected state if `err` is passed or\n * fulfilled state if no `err` is passed.\n *\n * @param {Error} [err] error or null\n * @param {Object} [val] value to fulfill the promise with\n * @api public\n */\nPromise.prototype.resolve = function (err, val) {\n  if (err) return this.reject(err);\n  return this.fulfill(val);\n};\n\n\n/**\n * Adds a listener to the SUCCESS event.\n *\n * @return {MPromise} this\n * @api public\n */\nPromise.prototype.onFulfill = function (fn) {\n  if (!fn) return this;\n  if ('function' != typeof fn) throw new TypeError(\"fn should be a function\");\n  return this.on(Promise.SUCCESS, fn);\n};\n\n\n/**\n * Adds a listener to the FAILURE event.\n *\n * @return {MPromise} this\n * @api public\n */\nPromise.prototype.onReject = function (fn) {\n  if (!fn) return this;\n  if ('function' != typeof fn) throw new TypeError(\"fn should be a function\");\n  return this.on(Promise.FAILURE, fn);\n};\n\n\n/**\n * Adds a single function as a listener to both SUCCESS and FAILURE.\n *\n * It will be executed with traditional node.js argument position:\n * function (err, args...) {}\n *\n * Also marks the promise as `end`ed, since it's the common use-case, and yet has no\n * side effects unless `fn` is undefined or null.\n *\n * @param {Function} fn\n * @return {MPromise} this\n */\nPromise.prototype.onResolve = function (fn) {\n  if (!fn) return this;\n  if ('function' != typeof fn) throw new TypeError(\"fn should be a function\");\n  this.on(Promise.FAILURE, function (err) { fn.call(this, err); });\n  this.on(Promise.SUCCESS, function () { fn.apply(this, strongUnshift(null, arguments)); });\n  return this;\n};\n\n\n/**\n * Creates a new promise and returns it. If `onFulfill` or\n * `onReject` are passed, they are added as SUCCESS/ERROR callbacks\n * to this promise after the next tick.\n *\n * Conforms to [promises/A+](https://github.com/promises-aplus/promises-spec) specification. Read for more detail how to use this method.\n *\n * ####Example:\n *\n *     var p = new Promise;\n *     p.then(function (arg) {\n *       return arg + 1;\n *     }).then(function (arg) {\n *       throw new Error(arg + ' is an error!');\n *     }).then(null, function (err) {\n *       assert.ok(err instanceof Error);\n *       assert.equal('2 is an error', err.message);\n *     });\n *     p.complete(1);\n *\n * @see promises-A+ https://github.com/promises-aplus/promises-spec\n * @param {Function} onFulfill\n * @param {Function} [onReject]\n * @return {MPromise} newPromise\n */\nPromise.prototype.then = function (onFulfill, onReject) {\n  var newPromise = new Promise;\n\n  if ('function' == typeof onFulfill) {\n    this.onFulfill(handler(newPromise, onFulfill));\n  } else {\n    this.onFulfill(newPromise.fulfill.bind(newPromise));\n  }\n\n  if ('function' == typeof onReject) {\n    this.onReject(handler(newPromise, onReject));\n  } else {\n    this.onReject(newPromise.reject.bind(newPromise));\n  }\n\n  return newPromise;\n};\n\n\nfunction handler(promise, fn) {\n  function newTickHandler() {\n    var pDomain = promise.emitter.domain;\n    if (pDomain && pDomain !== process.domain) pDomain.enter();\n    try {\n      var x = fn.apply(undefined, boundHandler.args);\n    } catch (err) {\n      promise.reject(err);\n      return;\n    }\n    resolve(promise, x);\n  }\n  function boundHandler() {\n    boundHandler.args = arguments;\n    process.nextTick(newTickHandler);\n  }\n  return boundHandler;\n}\n\n\nfunction resolve(promise, x) {\n  function fulfillOnce() {\n    if (done++) return;\n    resolve.apply(undefined, strongUnshift(promise, arguments));\n  }\n  function rejectOnce(reason) {\n    if (done++) return;\n    promise.reject(reason);\n  }\n\n  if (promise === x) {\n    promise.reject(new TypeError(\"promise and x are the same\"));\n    return;\n  }\n  var rest = toArray(arguments, 1);\n  var type = typeof x;\n  if ('undefined' == type || null == x || !('object' == type || 'function' == type)) {\n    promise.fulfill.apply(promise, rest);\n    return;\n  }\n\n  try {\n    var theThen = x.then;\n  } catch (err) {\n    promise.reject(err);\n    return;\n  }\n\n  if ('function' != typeof theThen) {\n    promise.fulfill.apply(promise, rest);\n    return;\n  }\n\n  var done = 0;\n  try {\n    var ret = theThen.call(x, fulfillOnce, rejectOnce);\n    return ret;\n  } catch (err) {\n    if (done++) return;\n    promise.reject(err);\n  }\n}\n\n\n/**\n * Signifies that this promise was the last in a chain of `then()s`: if a handler passed to the call to `then` which produced this promise throws, the exception will go uncaught.\n *\n * ####Example:\n *\n *     var p = new Promise;\n *     p.then(function(){ throw new Error('shucks') });\n *     setTimeout(function () {\n *       p.fulfill();\n *       // error was caught and swallowed by the promise returned from\n *       // p.then(). we either have to always register handlers on\n *       // the returned promises or we can do the following...\n *     }, 10);\n *\n *     // this time we use .end() which prevents catching thrown errors\n *     var p = new Promise;\n *     var p2 = p.then(function(){ throw new Error('shucks') }).end(); // <--\n *     setTimeout(function () {\n *       p.fulfill(); // throws \"shucks\"\n *     }, 10);\n *\n * @api public\n * @param {Function} [onReject]\n * @return {MPromise} this\n */\nPromise.prototype.end = Promise.prototype['catch'] = function (onReject) {\n  if (!onReject && !this.hasRejectListeners())\n    onReject = function idRejector(e) { throw e; };\n  this.onReject(onReject);\n  this.ended = true;\n  return this;\n};\n\n\n/**\n * A debug utility function that adds handlers to a promise that will log some output to the `console`\n *\n * ####Example:\n *\n *     var p = new Promise;\n *     p.then(function(){ throw new Error('shucks') });\n *     setTimeout(function () {\n *       p.fulfill();\n *       // error was caught and swallowed by the promise returned from\n *       // p.then(). we either have to always register handlers on\n *       // the returned promises or we can do the following...\n *     }, 10);\n *\n *     // this time we use .end() which prevents catching thrown errors\n *     var p = new Promise;\n *     var p2 = p.then(function(){ throw new Error('shucks') }).end(); // <--\n *     setTimeout(function () {\n *       p.fulfill(); // throws \"shucks\"\n *     }, 10);\n *\n * @api public\n * @param {MPromise} p\n * @param {String} name\n * @return {MPromise} this\n */\nPromise.trace = function (p, name) {\n  p.then(\n    function () {\n      console.log(\"%s fulfill %j\", name, toArray(arguments));\n    },\n    function () {\n      console.log(\"%s reject %j\", name, toArray(arguments));\n    }\n  )\n};\n\n\nPromise.prototype.chain = function (p2) {\n  var p1 = this;\n  p1.onFulfill(p2.fulfill.bind(p2));\n  p1.onReject(p2.reject.bind(p2));\n  return p2;\n};\n\n\nPromise.prototype.all = function (promiseOfArr) {\n  var pRet = new Promise;\n  this.then(promiseOfArr).then(\n    function (promiseArr) {\n      var count = 0;\n      var ret = [];\n      var errSentinel;\n      if (!promiseArr.length) pRet.resolve();\n      promiseArr.forEach(function (promise, index) {\n        if (errSentinel) return;\n        count++;\n        promise.then(\n          function (val) {\n            if (errSentinel) return;\n            ret[index] = val;\n            --count;\n            if (count == 0) pRet.fulfill(ret);\n          },\n          function (err) {\n            if (errSentinel) return;\n            errSentinel = err;\n            pRet.reject(err);\n          }\n        );\n      });\n      return pRet;\n    }\n    , pRet.reject.bind(pRet)\n  );\n  return pRet;\n};\n\n\nPromise.hook = function (arr) {\n  var p1 = new Promise;\n  var pFinal = new Promise;\n  var signalP = function () {\n    --count;\n    if (count == 0)\n      pFinal.fulfill();\n    return pFinal;\n  };\n  var count = 1;\n  var ps = p1;\n  arr.forEach(function (hook) {\n    ps = ps.then(\n      function () {\n        var p = new Promise;\n        count++;\n        hook(p.resolve.bind(p), signalP);\n        return p;\n      }\n    )\n  });\n  ps = ps.then(signalP);\n  p1.resolve();\n  return ps;\n};\n\n\n/* This is for the A+ tests, but it's very useful as well */\nPromise.fulfilled = function fulfilled() { var p = new Promise; p.fulfill.apply(p, arguments); return p; };\nPromise.rejected = function rejected(reason) { return new Promise().reject(reason); };\nPromise.deferred = function deferred() {\n  var p = new Promise;\n  return {\n    promise: p,\n    reject: p.reject.bind(p),\n    resolve: p.fulfill.bind(p),\n    callback: p.resolve.bind(p)\n  }\n};\n/* End A+ tests adapter bit */\n"]}
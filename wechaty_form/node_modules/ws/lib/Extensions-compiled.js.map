{"version":3,"sources":["Extensions.js"],"names":[],"mappings":"AAAA;;AAEA;;;;;;;;AAOA,MAAM,QAAS,KAAD,IAAW;AACvB,UAAQ,SAAS,EAAjB;;AAEA,QAAM,aAAa,EAAnB;;AAEA,QAAM,KAAN,CAAY,GAAZ,EAAiB,OAAjB,CAA0B,CAAD,IAAO;AAC9B,UAAM,SAAS,EAAE,KAAF,CAAQ,GAAR,CAAf;AACA,UAAM,QAAQ,OAAO,KAAP,GAAe,IAAf,EAAd;AACA,UAAM,aAAa,WAAW,KAAX,IAAoB,WAAW,KAAX,KAAqB,EAA5D;AACA,UAAM,eAAe,EAArB;;AAEA,WAAO,OAAP,CAAgB,KAAD,IAAW;AACxB,YAAM,QAAQ,MAAM,IAAN,GAAa,KAAb,CAAmB,GAAnB,CAAd;AACA,YAAM,MAAM,MAAM,CAAN,CAAZ;AACA,UAAI,QAAQ,MAAM,CAAN,CAAZ;;AAEA,UAAI,UAAU,SAAd,EAAyB;AACvB,gBAAQ,IAAR;AACD,OAFD,MAEO;AACL;AACA,YAAI,MAAM,CAAN,MAAa,GAAjB,EAAsB;AACpB,kBAAQ,MAAM,KAAN,CAAY,CAAZ,CAAR;AACD;AACD,YAAI,MAAM,MAAM,MAAN,GAAe,CAArB,MAA4B,GAAhC,EAAqC;AACnC,kBAAQ,MAAM,KAAN,CAAY,CAAZ,EAAe,MAAM,MAAN,GAAe,CAA9B,CAAR;AACD;AACF;AACD,OAAC,aAAa,GAAb,IAAoB,aAAa,GAAb,KAAqB,EAA1C,EAA8C,IAA9C,CAAmD,KAAnD;AACD,KAjBD;;AAmBA,eAAW,IAAX,CAAgB,YAAhB;AACD,GA1BD;;AA4BA,SAAO,UAAP;AACD,CAlCD;;AAoCA;;;;;;;AAOA,MAAM,SAAU,KAAD,IAAW;AACxB,SAAO,OAAO,IAAP,CAAY,KAAZ,EAAmB,GAAnB,CAAwB,KAAD,IAAW;AACvC,QAAI,aAAa,MAAM,KAAN,CAAjB;AACA,QAAI,CAAC,MAAM,OAAN,CAAc,UAAd,CAAL,EAAgC,aAAa,CAAC,UAAD,CAAb;AAChC,WAAO,WAAW,GAAX,CAAgB,MAAD,IAAY;AAChC,aAAO,CAAC,KAAD,EAAQ,MAAR,CAAe,OAAO,IAAP,CAAY,MAAZ,EAAoB,GAApB,CAAyB,CAAD,IAAO;AACnD,YAAI,IAAI,OAAO,CAAP,CAAR;AACA,YAAI,CAAC,MAAM,OAAN,CAAc,CAAd,CAAL,EAAuB,IAAI,CAAC,CAAD,CAAJ;AACvB,eAAO,EAAE,GAAF,CAAO,CAAD,IAAO,MAAM,IAAN,GAAa,CAAb,GAAkB,IAAE,CAAE,MAAG,CAAE,GAAxC,EAA2C,IAA3C,CAAgD,IAAhD,CAAP;AACD,OAJqB,CAAf,EAIH,IAJG,CAIE,IAJF,CAAP;AAKD,KANM,EAMJ,IANI,CAMC,IAND,CAAP;AAOD,GAVM,EAUJ,IAVI,CAUC,IAVD,CAAP;AAWD,CAZD;;AAcA,OAAO,OAAP,GAAiB,EAAE,MAAF,EAAU,KAAV,EAAjB","file":"Extensions-compiled.js","sourcesContent":["'use strict';\n\n/**\n * Parse the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} value field value of the header\n * @return {Object} The parsed object\n * @public\n */\nconst parse = (value) => {\n  value = value || '';\n\n  const extensions = {};\n\n  value.split(',').forEach((v) => {\n    const params = v.split(';');\n    const token = params.shift().trim();\n    const paramsList = extensions[token] = extensions[token] || [];\n    const parsedParams = {};\n\n    params.forEach((param) => {\n      const parts = param.trim().split('=');\n      const key = parts[0];\n      var value = parts[1];\n\n      if (value === undefined) {\n        value = true;\n      } else {\n        // unquote value\n        if (value[0] === '\"') {\n          value = value.slice(1);\n        }\n        if (value[value.length - 1] === '\"') {\n          value = value.slice(0, value.length - 1);\n        }\n      }\n      (parsedParams[key] = parsedParams[key] || []).push(value);\n    });\n\n    paramsList.push(parsedParams);\n  });\n\n  return extensions;\n};\n\n/**\n * Serialize a parsed `Sec-WebSocket-Extensions` header to a string.\n *\n * @param {Object} value The object to format\n * @return {String} A string representing the given value\n * @public\n */\nconst format = (value) => {\n  return Object.keys(value).map((token) => {\n    var paramsList = value[token];\n    if (!Array.isArray(paramsList)) paramsList = [paramsList];\n    return paramsList.map((params) => {\n      return [token].concat(Object.keys(params).map((k) => {\n        var p = params[k];\n        if (!Array.isArray(p)) p = [p];\n        return p.map((v) => v === true ? k : `${k}=${v}`).join('; ');\n      })).join('; ');\n    }).join(', ');\n  }).join(', ');\n};\n\nmodule.exports = { format, parse };\n"]}